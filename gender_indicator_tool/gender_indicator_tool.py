# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GenderIndicatorTool
                                 A QGIS plugin
 Gender Indicator Tool
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-07-15
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Pegasys
        email                : andre@pegasys.co.za
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# QGIS and PyQt libraries and modules
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from PyQt5.QtWidgets import QFileDialog, QApplication
from qgis.core import *

# Auxiliary libraries
import os
import sys
import geopandas as gpd
import pandas as pd
from rasterio.crs import CRS
import rasterio
import numpy as np
import math
import shutil
import time
import logging
import ast
from rasterio.mask import mask
from rasterio.features import geometry_mask

# Prepare processing framework
# sys.path.append(r'C:\Program Files\QGIS 3.32.0\apps\qgis\python\plugins') # Folder where Processing is located
from processing.core.Processing import Processing
Processing.initialize()
import processing
import sys
from qgis.PyQt import QtWidgets

# Use pdb for debugging
import pdb
# also import pyqtRemoveInputHook
from qgis.PyQt.QtCore import pyqtRemoveInputHook
from qgis.core import QgsMessageLog

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .gender_indicator_tool_dialog import GenderIndicatorToolDialog

#test
class GenderIndicatorTool:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        
        # Show commands button only shown in debug mode
        # Fetch the value of GEEST_DEBUG from an environment variable
        debug_mode = int(os.getenv("GEEST_DEBUG", 0))
        if debug_mode:
            import multiprocessing  # pylint: disable=import-outside-toplevel
            if multiprocessing.current_process().pid > 1:
                import debugpy  # pylint: disable=import-outside-toplevel

                debugpy.listen(("0.0.0.0", 9000))
                debugpy.wait_for_client()
                #self.display_information_message_bar(
                #     title="Animation Workbench",
                #     message="Visual Studio Code debugger is now attached on port 9000",
                #)
                    
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GenderIndicatorTool_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Gender Enabling Environments Spatial Tool (GEEST)')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GenderIndicatorTool', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/gender_indicator_tool/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'GEEST'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&World Bank Gender Indicator Tool'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = GenderIndicatorToolDialog()

        # show the dialog
        self.dlg.show()


        ## TAB 1 - Analysis Setup ***********************************************************************
        self.dlg.workingDir_Button.clicked.connect(lambda: self.getFolder(0))



        ## TAB 2 - Individual ***************************************************************************
        ###### TAB 2.1 - Education
        self.dlg.EDU_Set_PB.clicked.connect(lambda: self.RasterizeSet(0))
        self.dlg.EDU_Execute_PB.clicked.connect(lambda: self.Rasterize(0))

        ###### TAB 2.2 - Care Responsibilities
        self.dlg.CRE_Set_PB.clicked.connect(lambda: self.RasterizeSet(1))
        self.dlg.CRE_Execute_PB.clicked.connect(lambda: self.Rasterize(1))

        ###### TAB 2.3 - Domestic Violence
        self.dlg.DOV_Set_PB.clicked.connect(lambda: self.RasterizeSet(2))
        self.dlg.DOV_Execute_PB.clicked.connect(lambda: self.Rasterize(2))

        ###### TAB 2.4 - Aggregate
        self.dlg.EDU_Aggregate_TB.clicked.connect(lambda: self.getFile(0))
        self.dlg.CRE_Aggregate_TB.clicked.connect(lambda: self.getFile(1))
        self.dlg.DOV_Aggregate_TB.clicked.connect(lambda: self.getFile(2))

        self.dlg.Indivdual_AggregateExecute_PB.clicked.connect(self.indivdualAggregation)

        ## TAB 3 - Contextual ***************************************************************************
        ###### TAB 3.1 - Policy and Legal Protection
        self.dlg.PLP_Set_PB.clicked.connect(lambda: self.RasterizeSet(3))
        self.dlg.PLP_Execute_PB.clicked.connect(lambda: self.Rasterize(3))

        ###### TAB 3.2 - Access to Finance
        self.dlg.FIN_Set_PB.clicked.connect(lambda: self.RasterizeSet(4))
        self.dlg.FIN_Execute_PB.clicked.connect(lambda: self.Rasterize(4))

        ###### TAB 3.2 - Aggregate
        self.dlg.PLP_Aggregate_TB.clicked.connect(lambda: self.getFile(3))
        self.dlg.FIN_Aggregate_TB.clicked.connect(lambda: self.getFile(4))

        self.dlg.Contextual_AggregateExecute_PB.clicked.connect(self.contextualAggregation)


        ## TAB 4 - Accessibility ************************************************************************
        Modes = ['Walking', 'Driving']
        Measurement = ['Distance', 'Time']

        ###### TAB 4.1 - Women's Travel Patterns
        self.dlg.WTP_mode_CB.clear()
        self.dlg.WTP_mode_CB.addItems(Modes)
        self.dlg.WTP_measurement_CB.clear()
        self.dlg.WTP_measurement_CB.addItems(Measurement)
        self.dlg.WTP_Execute_PB.clicked.connect(lambda: self.ServiceArea(5))

        self.dlg.WTP_Aggregate_PB.clicked.connect(self.wtpAggregate)

        ###### TAB 4.2 - Public Transport
        self.dlg.PBT_mode_CB.clear()
        self.dlg.PBT_mode_CB.addItems(Modes)
        self.dlg.PBT_measurement_CB.clear()
        self.dlg.PBT_measurement_CB.addItems(Measurement)
        self.dlg.PBT_Execute_PB.clicked.connect(lambda: self.ServiceArea(0))

        ###### TAB 4.3 - Ediucation & Training
        self.dlg.ETF_mode_CB.clear()
        self.dlg.ETF_mode_CB.addItems(Modes)
        self.dlg.ETF_measurement_CB.clear()
        self.dlg.ETF_measurement_CB.addItems(Measurement)
        self.dlg.ETF_Execute_PB.clicked.connect(lambda: self.ServiceArea(1))

        ###### TAB 4.4 - Jobs
        self.dlg.JOB_mode_CB.clear()
        self.dlg.JOB_mode_CB.addItems(Modes)
        self.dlg.JOB_measurement_CB.clear()
        self.dlg.JOB_measurement_CB.addItems(Measurement)
        self.dlg.JOB_Execute_PB.clicked.connect(lambda: self.ServiceArea(2))

        ###### TAB 4.5 - Health Facilities
        self.dlg.HEA_mode_CB.clear()
        self.dlg.HEA_mode_CB.addItems(Modes)
        self.dlg.HEA_measurement_CB.clear()
        self.dlg.HEA_measurement_CB.addItems(Measurement)
        self.dlg.HEA_Execute_PB.clicked.connect(lambda: self.ServiceArea(3))

        ###### TAB 4.6 - Financial Facilities
        self.dlg.FIF_mode_CB.clear()
        self.dlg.FIF_mode_CB.addItems(Modes)
        self.dlg.FIF_measurement_CB.clear()
        self.dlg.FIF_measurement_CB.addItems(Measurement)
        self.dlg.FIF_Execute_PB.clicked.connect(lambda: self.ServiceArea(4))

        ###### TAB 4.7 - Aggregate
        self.dlg.WTP_Aggregate_TB.clicked.connect(lambda: self.getFile(5))
        self.dlg.PBT_Aggregate_TB.clicked.connect(lambda: self.getFile(6))
        self.dlg.ETF_Aggregate_TB.clicked.connect(lambda: self.getFile(7))
        self.dlg.JOB_Aggregate_TB.clicked.connect(lambda: self.getFile(8))
        self.dlg.HEA_Aggregate_TB.clicked.connect(lambda: self.getFile(9))
        self.dlg.FIF_Aggregate_TB.clicked.connect(lambda: self.getFile(10))
        self.dlg.Accessibility_AggregateExecute_PB.clicked.connect(self.accessibiltyAggregation)


        ## TAB 5 - Place Charqacterization **************************************************************
        ###### TAB 5.1 - Walkability / Active Transport
        self.dlg.WLK_Set_PB.clicked.connect(lambda: self.TypeSet(1))
        self.dlg.WLK_unique_PB.clicked.connect(lambda: self.uniqueValues(1))
        self.dlg.WLK_Execute_PB.clicked.connect(self.walkability)

        ###### TAB 5.2 - Public Transport
        self.dlg.APT_Execute_PB.clicked.connect(self.transportCount)

        ###### TAB 5.3 - Safe Urban Design
        self.dlg.SAF_Execute_PB.clicked.connect(self.SAFnightTimeLights)

        ###### TAB 5.4 - Security
        self.dlg.SEC_Set_PB.clicked.connect(lambda: self.RasterizeSet(6))
        self.dlg.SEC_Execute_PB.clicked.connect(lambda: self.Rasterize(6))
        self.dlg.SEC_Aggregate_PB.clicked.connect(self.secAggregate)

        ###### TAB 5.5 - Income Level
        self.dlg.INC_Set_PB.clicked.connect(lambda: self.RasterizeSet(5))
        self.dlg.INC_Execute_PB.clicked.connect(lambda: self.Rasterize(5))

        ###### TAB 5.6 - Electrical Access
        self.dlg.ELC_Set_PB.clicked.connect(lambda: self.RasterizeSet(7))
        self.dlg.ELC_Execute_PB.clicked.connect(lambda: self.Rasterize(7))
        self.dlg.ELC_NTLExecute_PB.clicked.connect(self.ELCnightTimeLights)

        ###### TAB 5.7 - Urbanization
        self.dlg.LOU_Execute_PB.clicked.connect(self.urbanization)

        ###### TAB 5.8 - Housing
        self.dlg.QUH_Execute_PB.clicked.connect(self.housing)

        ###### TAB 5.9 - Digital Inclusion
        self.dlg.DIG_Set_PB.clicked.connect(lambda: self.RasterizeSet(8))
        self.dlg.DIG_Execute_PB.clicked.connect(lambda: self.Rasterize(8))

        ###### TAB 5.10 - Natural Environment
        self.dlg.ENV_Set_PB.clicked.connect(lambda: self.TypeSet(3))
        self.dlg.ENV_unique_PB.clicked.connect(lambda: self.uniqueValues(3))
        self.dlg.ENV_Execute_PB.clicked.connect(self.natEnvironment)
        self.dlg.ENV_Aggregate_PB.clicked.connect(self.envAggregate)

        ###### TAB 5.11 - Aggregate
        self.dlg.WLK_Aggregate_TB.clicked.connect(lambda: self.getFile(11))
        self.dlg.APT_Aggregate_TB.clicked.connect(lambda: self.getFile(13))
        self.dlg.SAF_Aggregate_TB.clicked.connect(lambda: self.getFile(14))
        self.dlg.SEC_Aggregate_TB.clicked.connect(lambda: self.getFile(15))
        self.dlg.INC_Aggregate_TB.clicked.connect(lambda: self.getFile(16))
        self.dlg.ELC_Aggregate_TB.clicked.connect(lambda: self.getFile(17))
        self.dlg.LOU_Aggregate_TB.clicked.connect(lambda: self.getFile(18))
        self.dlg.QUH_Aggregate_TB.clicked.connect(lambda: self.getFile(19))
        self.dlg.DIG_Aggregate_TB.clicked.connect(lambda: self.getFile(20))
        self.dlg.ENV_Aggregate_TB.clicked.connect(lambda: self.getFile(21))
        self.dlg.PlaceCharacterization_AggregateExecute_PB.clicked.connect(self.placeCharacterizationAggregation)

        ## TAB 6 - Dimension Aggregation ************************************************************************
        self.dlg.ID_Aggregate_TB.clicked.connect(lambda: self.getFile(22))
        self.dlg.CD_Aggregate_TB.clicked.connect(lambda: self.getFile(23))
        self.dlg.AD_Aggregate_TB.clicked.connect(lambda: self.getFile(24))
        self.dlg.PD_Aggregate_TB.clicked.connect(lambda: self.getFile(25))
        self.dlg.Dimensions_AggregateExecute_PB.clicked.connect(self.dimesnionsAggregation)

        ## TAB 7 - Insights ************************************************************************
        ###### TAB 7.1 - Enablement
        self.dlg.Score_reclassify.clicked.connect(self.scoreReclassInsights)
        self.dlg.Pop_reclassify.clicked.connect(self.populationReclassInsights)
        self.dlg.Combine_reclassify.clicked.connect(self.combineReclassInsights)
        self.dlg.Aggregation_Execute_PB.clicked.connect(self.Aggregationinsights)

        ###### TAB 7.2 - Raster Locations
        self.dlg.RE_Execute_PB.clicked.connect(self.reZones)

        ###### TAB 7.3 - Point Locations
        self.dlg.Buffer_Execute_PB.clicked.connect(self.Bufferinsights)

    def getFile(self, button_num):
        '''
        Function used for all factor tabs to browse files and retrieve filepaths required to be used as input to other functions.

        Factors it is applied:
        - All
        '''
        response = QFileDialog.getOpenFileName(
            parent=self.dlg,
            caption='Select a file',
            directory=os.getcwd()
        )

        if button_num == 0:
            self.dlg.EDU_Aggregate_Field.setText(response[0])

        elif button_num == 1:
            self.dlg.CRE_Aggregate_Field.setText(response[0])

        elif button_num == 2:
            self.dlg.DOV_Aggregate_Field.setText(response[0])

        elif button_num == 3:
            self.dlg.PLP_Aggregate_Field.setText(response[0])

        elif button_num == 4:
            self.dlg.FIN_Aggregate_Field.setText(response[0])

        elif button_num == 5:
            self.dlg.WTP_Aggregate_Field.setText(response[0])

        elif button_num == 6:
            self.dlg.PBT_Aggregate_Field.setText(response[0])

        elif button_num == 7:
            self.dlg.ETF_Aggregate_Field.setText(response[0])

        elif button_num == 8:
            self.dlg.JOB_Aggregate_Field.setText(response[0])

        elif button_num == 9:
            self.dlg.HEA_Aggregate_Field.setText(response[0])

        elif button_num == 10:
            self.dlg.FIF_Aggregate_Field.setText(response[0])

        elif button_num == 11:
            self.dlg.WLK_Aggregate_Field.setText(response[0])

        elif button_num == 12:
            self.dlg.CYC_Aggregate_Field.setText(response[0])

        elif button_num == 13:
            self.dlg.APT_Aggregate_Field.setText(response[0])

        elif button_num == 14:
            self.dlg.SAF_Aggregate_Field.setText(response[0])

        elif button_num == 15:
            self.dlg.SEC_Aggregate_Field.setText(response[0])

        elif button_num == 16:
            self.dlg.INC_Aggregate_Field.setText(response[0])

        elif button_num == 17:
            self.dlg.ELC_Aggregate_Field.setText(response[0])

        elif button_num == 18:
            self.dlg.LOU_Aggregate_Field.setText(response[0])

        elif button_num == 19:
            self.dlg.QUH_Aggregate_Field.setText(response[0])

        elif button_num == 20:
            self.dlg.DIG_Aggregate_Field.setText(response[0])

        elif button_num == 21:
            self.dlg.ENV_Aggregate_Field.setText(response[0])

        elif button_num == 22:
            self.dlg.ID_Aggregate_Field.setText(response[0])

        elif button_num == 23:
            self.dlg.CD_Aggregate_Field.setText(response[0])

        elif button_num == 24:
            self.dlg.AD_Aggregate_Field.setText(response[0])

        elif button_num == 25:
            self.dlg.PD_Aggregate_Field.setText(response[0])

    def getFolder(self, button_num):
        '''
        Function used to browse and retrieve filepath for project working directory selected in the setup tab
        '''
        response = QFileDialog.getExistingDirectory(
            parent=self.dlg,
            caption='Select a folder/directory',
            directory=os.getcwd()
        )

        if button_num == 0:
            # Clear the field before setting its text
            self.dlg.workingDir_Field.clear()
            self.dlg.workingDir_Field.setText(str(response + "/"))

    def RasterizeSet(self, factor_no):
        '''
        Used in combination with tabs that use the "Rasterization" function. This function is used to extract all the attribute table's field headings
        from the input vector layers. The extracted values are then populated in the drop-down menu allowing the user to select which fields values are to be used when
        executing the "Rasterization" function.

        Factors it is applied:
            Individual Dimension
                - Education
                - Care Responsibilities
                - Domestic Violence
            Contextual Dimension
                - Policy and Legal Protection
                - Access to Finance
            Place Characterization Dimension
                - Security
                - Income Level
                - Electrical Access
                - Digital Inclusion

        '''
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.EDU_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.EDU_rasField_CB.addItems(fields)

        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.CRE_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.CRE_rasField_CB.addItems(fields)

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.DOV_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.DOV_rasField_CB.addItems(fields)

        elif factor_no == 3:
            polygonlayer = self.dlg.PLP_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.PLP_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.PLP_rasField_CB.addItems(fields)

        elif factor_no == 4:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.FIN_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.FIN_rasField_CB.addItems(fields)

        elif factor_no == 5:
            polygonlayer = self.dlg.INC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.INC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.INC_rasField_CB.addItems(fields)

        elif factor_no == 6:
            polygonlayer = self.dlg.SEC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.SEC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.SEC_rasField_CB.addItems(fields)

        elif factor_no == 7:
            polygonlayer = self.dlg.ELC_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.ELC_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.ELC_rasField_CB.addItems(fields)

        elif factor_no == 8:
            polygonlayer = self.dlg.DIG_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.DIG_rasField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.DIG_rasField_CB.addItems(fields)

    def TypeSet(self,factor_no):
        '''
        Similar to the "RasterizeSet" function this function is used to extract all the attribute table's field headings from the input vector layers. However,
        the extracted values are then populated in the drop-down menu where the user is to select which field from which they want extract the unique values. (See uniqueValues function)

        Factors it is applied:
            Place Characterization Dimension
                - Active Transport
                - Natural Environment and Climatic Factors
        '''
        if factor_no == 1:
            roadlayer = self.dlg.WLK_Input_Field.filePath()
            layer = QgsVectorLayer(roadlayer, "polygonlayer", 'ogr')
            self.dlg.WLK_roadTypeField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.WLK_roadTypeField_CB.addItems(fields)

        elif factor_no == 2:
            roadlayer = self.dlg.CYC_Input_Field.filePath()
            layer = QgsVectorLayer(roadlayer, "polygonlayer", 'ogr')
            self.dlg.CYC_roadTypeField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.CYC_roadTypeField_CB.addItems(fields)

        elif factor_no == 3:
            polygonlayer = self.dlg.ENV_Input_Field.filePath()
            layer = QgsVectorLayer(polygonlayer, "polygonlayer", 'ogr')
            self.dlg.ENV_riskLevelField_CB.clear()
            fields = [field.name() for field in layer.fields()]
            self.dlg.ENV_riskLevelField_CB.addItems(fields)

    def uniqueValues(self, factor_no):
        '''
        This function is used in combination with the "TypeSet" function. Once the field of interest in the polygon layer has been selected this function
        extracts all the unique values in the selected field and populates the empty field with a list of the unique value in the following format:

        [["low", 0], ["medium", 0], ["high", 0]]

        The user than assigns scores according to the standardized scaling system to each unique value as seen below:

        [["low", 4], ["medium", 2], ["high", 1]]

        Factors it is applied:
            Place Characterization Dimension
                - Active Transport
                - Natural Environment and Climatic Factors
        '''
        if factor_no == 1:
            gdf = gpd.read_file(self.dlg.WLK_Input_Field.filePath())
            roadTypeField = self.dlg.WLK_roadTypeField_CB.currentText()
            uniqueValues = gdf[roadTypeField].unique().tolist()
            scoreList = []

            for val in uniqueValues:
                scoreList.append([val,0])

            self.dlg.WLK_typeScore_Field.setText(str(scoreList))

        elif factor_no == 2:
            gdf = gpd.read_file(self.dlg.CYC_Input_Field.filePath())
            roadTypeField = self.dlg.CYC_roadTypeField_CB.currentText()
            self.dlg.CYC_roadType_CB.clear()
            uniqueValues = gdf[roadTypeField].unique().tolist()
            self.dlg.CYC_roadType_CB.addItems(uniqueValues)

        if factor_no == 3:
            gdf = gpd.read_file(self.dlg.ENV_Input_Field.filePath())
            riskTypeField = self.dlg.ENV_riskLevelField_CB.currentText()
            uniqueValues = gdf[riskTypeField].unique().tolist()
            scoreList = []

            for val in uniqueValues:
                scoreList.append([val,0])

            self.dlg.ENV_typeScore_Field.setText(str(scoreList))

    def convertCRS(self, vector, UTM_crs):
        '''
        This function is used whenever a vector file's co-ordinate reference system needs to be reprojected so that it can be used as input into an algorithm.

        Factors it is applied:
        - All
        '''
        global shp_utm

        shp = gpd.read_file(vector)
        shp_wgs84 = shp.to_crs('EPSG:4326')
        shp_utm = shp_wgs84.to_crs(UTM_crs)

# *************************** Factor Functions ********************************** #
    def Rasterize(self, factor_no):
        '''
        Numerous functions use this function to convert vector file type into the standardized raster file types required for aggregation.

        Factors it is applied:
            Individual Dimension
                - Education
                - Care Responsibilities
                - Domestic Violence
            Contextual Dimension
                - Policy and Legal Protection
                - Access to Finance
            Place Characterization Dimension
                - Security
                - Income Level
                - Electrical Access
                - Digital Inclusion
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(":")[-1][:-1]

        #INPUT
        if factor_no == 0:
            polygonlayer = self.dlg.EDU_Input_Field.filePath()
            rasField = self.dlg.EDU_rasField_CB.currentText()
            self.dlg.EDU_status.setText("Variables Set")
            self.dlg.EDU_status.repaint()
            time.sleep(0.5)
            self.dlg.EDU_status.setText("Processing...")
            self.dlg.EDU_status.repaint()

        elif factor_no == 1:
            polygonlayer = self.dlg.CRE_Input_Field.filePath()
            rasField = self.dlg.CRE_rasField_CB.currentText()
            self.dlg.CRE_status.setText("Variables Set")
            self.dlg.CRE_status.repaint()
            time.sleep(0.5)
            self.dlg.CRE_status.setText("Processing...")
            self.dlg.CRE_status.repaint()

        elif factor_no == 2:
            polygonlayer = self.dlg.DOV_Input_Field.filePath()
            rasField = self.dlg.DOV_rasField_CB.currentText()
            self.dlg.DOV_status.setText("Variables Set")
            self.dlg.DOV_status.repaint()
            time.sleep(0.5)
            self.dlg.DOV_status.setText("Processing...")
            self.dlg.DOV_status.repaint()

        elif factor_no == 3:
            polygonlayer = self.dlg.PLP_Input_Field.filePath()
            rasField = self.dlg.PLP_rasField_CB.currentText()
            self.dlg.PLP_status.setText("Variables Set")
            self.dlg.PLP_status.repaint()
            time.sleep(0.5)
            self.dlg.PLP_status.setText("Processing...")
            self.dlg.PLP_status.repaint()

        elif factor_no == 4:
            polygonlayer = self.dlg.FIN_Input_Field.filePath()
            rasField = self.dlg.FIN_rasField_CB.currentText()
            self.dlg.FIN_status.setText("Variables Set")
            self.dlg.FIN_status.repaint()
            time.sleep(0.5)
            self.dlg.FIN_status.setText("Processing...")
            self.dlg.FIN_status.repaint()

        elif factor_no == 5:
            polygonlayer = self.dlg.INC_Input_Field.filePath()
            rasField = self.dlg.INC_rasField_CB.currentText()
            self.dlg.INC_status.setText("Variables Set")
            self.dlg.INC_status.repaint()
            time.sleep(0.5)
            self.dlg.INC_status.setText("Processing...")
            self.dlg.INC_status.repaint()

        elif factor_no == 6:
            polygonlayer = self.dlg.SEC_Input_Field.filePath()
            rasField = self.dlg.SEC_rasField_CB.currentText()
            self.dlg.SEC_status.setText("Variables Set")
            self.dlg.SEC_status.repaint()
            time.sleep(0.5)
            self.dlg.SEC_status.setText("Processing...")
            self.dlg.SEC_status.repaint()

        elif factor_no == 7:
            polygonlayer = self.dlg.ELC_Input_Field.filePath()
            rasField = self.dlg.ELC_rasField_CB.currentText()
            self.dlg.ELC_status.setText("Variables Set")
            self.dlg.ELC_status.repaint()
            time.sleep(0.5)
            self.dlg.ELC_status.setText("Processing...")
            self.dlg.ELC_status.repaint()

        elif factor_no == 8:
            polygonlayer = self.dlg.DIG_Input_Field.filePath()
            rasField = self.dlg.DIG_rasField_CB.currentText()
            self.dlg.DIG_status.setText("Variables Set")
            self.dlg.DIG_status.repaint()
            time.sleep(0.5)
            self.dlg.DIG_status.setText("Processing...")
            self.dlg.DIG_status.repaint()


        # Convert countryLayer data to UTM CRS
        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer =  QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                         'DISTANCE': 2000,
                                         'SEGMENTS': 5,
                                         'END_CAP_STYLE': 0,
                                         'JOIN_STYLE': 0,
                                         'MITER_LIMIT': 2,
                                         'DISSOLVE': True,
                                         'SEPARATE_DISJOINT': False,
                                         'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        # Convert spatial data to UTM CRS
        self.convertCRS(polygonlayer, UTM_crs)
        shp_utm[rasField] = shp_utm[rasField].astype(float)

        #Set variables required to conduct standardization of values
        Rmax = 100
        Rmin = 0
        m_max = 5
        m_min = 0
        if factor_no == 0:
            #Standardization formula
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Individual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.EDU_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.EDU_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.EDU_status.setText("Processing has been completed!")
            self.dlg.EDU_status.repaint()

        elif factor_no == 1:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Individual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.CRE_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.CRE_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.CRE_status.setText("Processing has been completed!")
            self.dlg.CRE_status.repaint()

        elif factor_no == 2:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Individual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.DOV_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DOV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.DOV_status.setText("Processing has been completed!")
            self.dlg.DOV_status.repaint()

        elif factor_no == 3:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.PLP_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.PLP_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.PLP_status.setText("Processing has been completed!")
            self.dlg.PLP_status.repaint()

        elif factor_no == 4:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Contextual"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.FIN_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.FIN_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.FIN_status.setText("Processing has been completed!")
            self.dlg.FIN_status.repaint()

        elif factor_no == 5:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.INC_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.INC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.INC_status.setText("Processing has been completed!")
            self.dlg.INC_status.repaint()

        elif factor_no == 6:
            shp_utm[rasField] = (shp_utm[rasField] - Rmax)/(Rmin - Rmax) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            Output_Folder = "SEC"
            if os.path.exists(Output_Folder):
                os.chdir(Output_Folder)
            else:
                os.mkdir(Output_Folder)
                os.chdir(Output_Folder)


            rasOutput = self.dlg.SEC_incidentOutput_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DOV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/{Output_Folder}"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.SEC_status.setText("Processing has been completed!")
            self.dlg.SEC_status.repaint()

        elif factor_no == 7:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.ELC_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.ELC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.ELC_status.setText("Processing has been completed!")
            self.dlg.ELC_status.repaint()

        elif factor_no == 8:
            shp_utm[rasField] = (shp_utm[rasField] - Rmin) / (Rmax - Rmin) * m_max
            polygonUTM = QgsVectorLayer(shp_utm.to_json(), "polygonUTM", "ogr")

            Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                              'OVERLAY': polygonUTM,
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})

            difference = Difference["OUTPUT"]

            Merge = processing.run("native:mergevectorlayers", {'LAYERS': [polygonUTM, difference],
                                                                'CRS': None,
                                                                'OUTPUT': "memory:"})

            mergeOutput = Merge["OUTPUT"]

            # Get the width and height of the extent
            extent = mergeOutput.extent()
            raster_width = int(extent.width() / pixelSize)
            raster_height = int(extent.height() / pixelSize)

            Dimension = "Place Characterization"
            if os.path.exists(Dimension):
                os.chdir(Dimension)
            else:
                os.mkdir(Dimension)
                os.chdir(Dimension)

            rasOutput = self.dlg.DIG_Output_Field.text()

            rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                          'FIELD': rasField,
                                                          'BURN': 0,
                                                          'USE_Z': False,
                                                          'UNITS': 0,
                                                          'WIDTH': raster_width,
                                                          'HEIGHT': raster_height,
                                                          'EXTENT': None,
                                                          'NODATA': None,
                                                          'OPTIONS': '',
                                                          'DATA_TYPE': 5,
                                                          'INIT': None,
                                                          'INVERT': False,
                                                          'EXTRA': '',
                                                          'OUTPUT': rasOutput})

            self.dlg.DIG_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

            self.dlg.DIG_status.setText("Processing has been completed!")
            self.dlg.DIG_status.repaint()

    def ServiceArea(self, factor_no):
        '''
        This function is used to conduct a service area network analysis facilitated using Openrouteservices' (ORS) isochrones service. Isochrones are derived from the OpenStreetMap (OSM) road network
        with the use of travel distances or times as input to estimate ease of access to the input locations at five incrementally increasing measurement intervals. The largest interval being the
        maximum distance or time taken to reach these locations. The algorithm produces five catchment areas based on the road network. A scoring system ranging from 5 to 1 is assigned to the catchment area
        polygons, reflecting the decreasing order of accessibility. Areas outside these catchment areas receive a score of zero.

        Service Area Analysis is undertaken using the openrouteservice API and OpenStreetMap data. © openrouteservice.org by HeiGIT | Road network data © OpenStreetMap contributors

        Factors it is applied:
            Accessibility Dimension
                - Women's Travel Patterns
                - Access to Public Transport
                - Access to Education and Training Facilities
                - Access to RE jobs
                - Access to Health Facilities
                - Access to Finance Facilities
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = f"{workingDir}temp"
        Dimension = "Accessibility"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(1)
        os.mkdir(tempDir)


        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()

        # INPUT
        if factor_no == 0:
            self.dlg.PBT_status.setText("")
            self.dlg.PBT_status.repaint()
            FaciltyPointlayer = self.dlg.PBT_Input_Field.filePath()
            ranges = self.dlg.PBT_Ranges_Field.text()
            rasOutput = f"{self.dlg.PBT_Output_Field.text()[:-4]}{self.dlg.PBT_mode_CB.currentText()}.tif"
            mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"


            self.dlg.PBT_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            if self.dlg.PBT_mode_CB.currentText() == "Driving":
                mode = 0
            elif self.dlg.PBT_mode_CB.currentText() == "Walking":
                mode = 6

            if self.dlg.PBT_measurement_CB.currentText() == "Time":
                measurement = 0
                ranges_field = "AA_MINS"
            elif self.dlg.PBT_measurement_CB.currentText() == "Distance":
                measurement = 1
                ranges_field = "AA_METERS"

            self.dlg.PBT_status.setText("Variables Set")
            self.dlg.PBT_status.repaint()
            time.sleep(0.5)
            self.dlg.PBT_status.setText("Processing...")
            self.dlg.PBT_status.repaint()

        elif factor_no == 1:
            self.dlg.ETF_status.setText("")
            self.dlg.ETF_status.repaint()
            FaciltyPointlayer = self.dlg.ETF_Input_Field.filePath()
            ranges = self.dlg.ETF_Ranges_Field.text()
            rasOutput = f"{self.dlg.ETF_Output_Field.text()[:-4]}{self.dlg.ETF_mode_CB.currentText()}.tif"
            mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            self.dlg.ETF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            if self.dlg.ETF_mode_CB.currentText() == "Driving":
                mode = 0
            elif self.dlg.ETF_mode_CB.currentText() == "Walking":
                mode = 6

            if self.dlg.ETF_measurement_CB.currentText() == "Time":
                measurement = 0
                ranges_field = "AA_MINS"
            elif self.dlg.ETF_measurement_CB.currentText() == "Distance":
                measurement = 1
                ranges_field = "AA_METERS"

            self.dlg.ETF_status.setText("Variables Set")
            self.dlg.ETF_status.repaint()
            time.sleep(0.5)
            self.dlg.ETF_status.setText("Processing...")
            self.dlg.ETF_status.repaint()


        elif factor_no == 2:
            self.dlg.JOB_status.setText("")
            self.dlg.JOB_status.repaint()
            FaciltyPointlayer = self.dlg.JOB_Input_Field.filePath()
            ranges = self.dlg.JOB_Ranges_Field.text()
            rasOutput = f"{self.dlg.JOB_Output_Field.text()[:-4]}{self.dlg.JOB_mode_CB.currentText()}.tif"
            mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            self.dlg.JOB_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            if self.dlg.JOB_mode_CB.currentText() == "Driving":
                mode = 0
            elif self.dlg.JOB_mode_CB.currentText() == "Walking":
                mode = 6

            if self.dlg.JOB_measurement_CB.currentText() == "Time":
                measurement = 0
                ranges_field = "AA_MINS"
            elif self.dlg.JOB_measurement_CB.currentText() == "Distance":
                measurement = 1
                ranges_field = "AA_METERS"

            self.dlg.JOB_status.setText("Variables Set")
            self.dlg.JOB_status.repaint()
            time.sleep(0.5)
            self.dlg.JOB_status.setText("Processing...")
            self.dlg.JOB_status.repaint()

        elif factor_no == 3:
            self.dlg.HEA_status.setText("")
            self.dlg.HEA_status.repaint()
            FaciltyPointlayer = self.dlg.HEA_Input_Field.filePath()
            ranges = self.dlg.HEA_Ranges_Field.text()
            rasOutput = f"{self.dlg.HEA_Output_Field.text()[:-4]}{self.dlg.HEA_mode_CB.currentText()}.tif"
            mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            self.dlg.HEA_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            if self.dlg.HEA_mode_CB.currentText() == "Driving":
                mode = 0
            elif self.dlg.HEA_mode_CB.currentText() == "Walking":
                mode = 6

            if self.dlg.HEA_measurement_CB.currentText() == "Time":
                measurement = 0
                ranges_field = "AA_MINS"
            elif self.dlg.HEA_measurement_CB.currentText() == "Distance":
                measurement = 1
                ranges_field = "AA_METERS"

            self.dlg.HEA_status.setText("Variables Set")
            self.dlg.HEA_status.repaint()
            time.sleep(0.5)
            self.dlg.HEA_status.setText("Processing...")
            self.dlg.HEA_status.repaint()

        elif factor_no == 4:
            self.dlg.FIF_status.setText("")
            self.dlg.FIF_status.repaint()
            FaciltyPointlayer = self.dlg.FIF_Input_Field.filePath()
            ranges = self.dlg.FIF_Ranges_Field.text()
            rasOutput = f"{self.dlg.FIF_Output_Field.text()[:-4]}{self.dlg.FIF_mode_CB.currentText()}.tif"
            mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/"
            styleFile = f"{rasOutput.split('.')[0]}.qml"

            self.dlg.FIF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

            if self.dlg.FIF_mode_CB.currentText() == "Driving":
                mode = 0
            elif self.dlg.FIF_mode_CB.currentText() == "Walking":
                mode = 6

            if self.dlg.FIF_measurement_CB.currentText() == "Time":
                measurement = 0
                ranges_field = "AA_MINS"
            elif self.dlg.FIF_measurement_CB.currentText() == "Distance":
                measurement = 1
                ranges_field = "AA_METERS"

            self.dlg.FIF_status.setText("Variables Set")
            self.dlg.FIF_status.repaint()
            time.sleep(0.5)
            self.dlg.FIF_status.setText("Processing...")
            self.dlg.FIF_status.repaint()

        elif factor_no == 5:
            self.dlg.WTP_status.setText("")
            self.dlg.WTP_status.repaint()
            FaciltyPointlayer = self.dlg.WTP_Input_Field.filePath()
            ranges = self.dlg.WTP_Ranges_Field.text()
            rasOutput = f"{self.dlg.WTP_FacilityOutput_Field.text()[:-4]}{self.dlg.WTP_mode_CB.currentText()}.tif"
            mergeOutput = f"{workingDir}{Dimension}/SA_SHP/{rasOutput[:-4]}_Service_Area.shp"


            if self.dlg.WTP_mode_CB.currentText() == "Driving":
                mode = 0
            elif self.dlg.WTP_mode_CB.currentText() == "Walking":
                mode = 6

            if self.dlg.WTP_measurement_CB.currentText() == "Time":
                measurement = 0
                ranges_field = "AA_MINS"
            elif self.dlg.WTP_measurement_CB.currentText() == "Distance":
                measurement = 1
                ranges_field = "AA_METERS"

            self.dlg.WTP_status.setText("Variables Set")
            self.dlg.WTP_status.repaint()
            time.sleep(0.5)
            self.dlg.WTP_status.setText("Processing...")
            self.dlg.WTP_status.repaint()

        #OUTPUT
        SAOutput_utm = f"{tempDir}/SA_OUTPUT_UTM.shp"
        temp_merge = f"{tempDir}/temp_merge.shp"

        gdf = gpd.read_file(FaciltyPointlayer)

        subset_size = 1
        subsets = []

        for i in range(0, len(gdf), subset_size):
            subset = gdf.iloc[i:i + subset_size]
            print(f"subset:{subset}")
            subset = QgsVectorLayer(subset.to_json(), "mygeojson", "ogr")
            subset_outfile = f"{tempDir}/SA_subset_{i + subset_size}_{rasOutput[:-4]}.shp"


            Service_Area = processing.run("ORS Tools:isochrones_from_layer", {'INPUT_PROVIDER': 0,
                                                                              'INPUT_PROFILE': mode,
                                                                              'INPUT_POINT_LAYER': subset,
                                                                              'INPUT_FIELD': '',
                                                                              'INPUT_METRIC': measurement,
                                                                              'INPUT_RANGES': ranges,
                                                                              'INPUT_SMOOTHING': None,
                                                                              'LOCATION_TYPE': 0,
                                                                              'INPUT_AVOID_FEATURES': [],
                                                                              'INPUT_AVOID_BORDERS': None,
                                                                              'INPUT_AVOID_COUNTRIES': '',
                                                                              'INPUT_AVOID_POLYGONS': None,
                                                                              'OUTPUT': subset_outfile})

            subsets.append(subset_outfile)

            batch = i + subset_size

            if batch > len(gdf):
                batch = len(gdf)
                
            print(f"Batch: {batch}")

            if factor_no == 0:
                self.dlg.PBT_status.setText(f"Processing... {batch} of {len(gdf)}")
                self.dlg.PBT_status.repaint()
            elif factor_no == 1:
                self.dlg.ETF_status.setText(f"Processing... {batch} of {len(gdf)}")
                self.dlg.ETF_status.repaint()
            elif factor_no == 2:
                self.dlg.JOB_status.setText(f"Processing... {batch} of {len(gdf)}")
                self.dlg.JOB_status.repaint()
            elif factor_no == 3:
                self.dlg.HEA_status.setText(f"Processing... {batch} of {len(gdf)}")
                self.dlg.HEA_status.repaint()
            elif factor_no == 4:
                self.dlg.FIF_status.setText(f"Processing... {batch} of {len(gdf)}")
                self.dlg.FIF_status.repaint()
            elif factor_no == 5:
                self.dlg.WTP_status.setText(f"Processing... {batch} of {len(gdf)}")
                self.dlg.WTP_status.repaint()


        print(f"Subsets debugging: {subsets}")

        Merge = processing.run(
            "native:mergevectorlayers", {'LAYERS': subsets,
                                                            'CRS': QgsCoordinateReferenceSystem(UTM_crs),
                                                            'OUTPUT': SAOutput_utm})

        time.sleep(0.5)

        # self.convertCRS(SAOutput_utm, UTM_crs)
        # SA_df = shp_utm
        SA_df = gpd.read_file(SAOutput_utm)
        no_spaces_string = "".join(ranges.split())
        ranges_list = no_spaces_string.split(",")
        int_ranges_list = [int(x) for x in ranges_list]
        int_ranges_list.sort()

        range_subsets = []

        for i in int_ranges_list:
            range_subset = SA_df[SA_df[ranges_field] == i]
            range_subset = QgsVectorLayer(range_subset.to_json(), f"range_{i}", "ogr")
            temp_out = f"{tempDir}/{rasOutput[:-4]}Range_dis_{i}.shp"

            dissolve = processing.run("native:dissolve", {'INPUT': range_subset,
                                                          'FIELD':[],
                                                          'SEPARATE_DISJOINT':False,
                                                          'OUTPUT':temp_out})

            Range_output = dissolve["OUTPUT"]

            range_subsets.append(range_subset)

        Merge_list = []

        for i in range(-1, -len(range_subsets), -1):
            output = f"{tempDir}/band_dif_{int_ranges_list[i]}_-_{int_ranges_list[i-1]}.shp"
            # Merge_list.append(output)
            difference = processing.run("native:difference", {'INPUT': range_subsets[i],
                                                              'OVERLAY': range_subsets[i-1],
                                                              'OUTPUT': "memory:",
                                                              'GRID_SIZE': None})
            diff_output = difference["OUTPUT"]

            dissolve = processing.run("native:dissolve", {'INPUT': diff_output,
                                                          'FIELD': [],
                                                          'SEPARATE_DISJOINT': False,
                                                          'OUTPUT': "memory:"})

            dis_output = dissolve["OUTPUT"]
            Merge_list.append(dis_output)



        dissolve = processing.run("native:dissolve", {'INPUT': range_subsets[0],
                                                      'FIELD': [],
                                                      'SEPARATE_DISJOINT': False,
                                                      'OUTPUT': "memory:"})

        dis_output = dissolve["OUTPUT"]
        Merge_list.append(dis_output)

        if os.path.exists(f"{Dimension}/SA_SHP"):
            pass
        else:
            os.mkdir(f"{Dimension}/SA_SHP")

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': Merge_list,
                                                            'CRS':None,
                                                            'OUTPUT':f"{mergeOutput}"})


        merge_df = gpd.read_file(f"{mergeOutput}")
        merge_df["rasField"] = [1,2,3,4,5]
        merge_SA_UTM = QgsVectorLayer(merge_df.to_json(), "merge_SA_utm", "ogr")

        # Convert countryLayer data to UTM CRS
        self.convertCRS(countryLayer, UTM_crs)
        shp_utm["rasField"] = [0]
        shp_utm_ = QgsVectorLayer(shp_utm.to_json(), "shp_utm", "ogr")
        # shp_utm.to_file(countryUTMLayer)

        buffer = processing.run("native:buffer", {'INPUT': shp_utm_,
                                         'DISTANCE': 2000,
                                         'SEGMENTS': 5,
                                         'END_CAP_STYLE': 0,
                                         'JOIN_STYLE': 0,
                                         'MITER_LIMIT': 2,
                                         'DISSOLVE': True,
                                         'SEPARATE_DISJOINT': False,
                                         'OUTPUT': "memory:"})

        buffer_output = buffer["OUTPUT"]

        Difference = processing.run("native:difference", {'INPUT': buffer_output,
                                                          'OVERLAY':merge_SA_UTM,
                                                          'OUTPUT':"memory:",
                                                          'GRID_SIZE':None})

        diff_output = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [merge_SA_UTM, diff_output],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        merge_output = Merge["OUTPUT"]

        extent = merge_output.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)


        if os.path.exists(Dimension):
            os.chdir(Dimension)
        else:
            os.mkdir(Dimension)
            os.chdir(Dimension)

        if factor_no == 5:
            Output_Folder = "WTP"
            if os.path.exists(Output_Folder):
                os.chdir(Output_Folder)
            else:
                os.mkdir(Output_Folder)
                os.chdir(Output_Folder)

            styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
            styleFileDestination = f"{workingDir}{Dimension}/{Output_Folder}"
            styleFile = f"{rasOutput.split('.')[0]}.qml"
        else:
            pass

        rasterize = processing.run("gdal:rasterize", {'INPUT': merge_output,
                                                      'FIELD': "rasField",
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        if factor_no == 0:
            self.dlg.PBT_status.setText("Processing Complete!")
            self.dlg.PBT_status.repaint()

        elif factor_no == 1:
            self.dlg.ETF_status.setText("Processing Complete!")
            self.dlg.ETF_status.repaint()

        elif factor_no == 2:
            self.dlg.JOB_status.setText("Processing Complete!")
            self.dlg.JOB_status.repaint()

        elif factor_no == 3:
            self.dlg.HEA_status.setText("Processing Complete!")
            self.dlg.HEA_status.repaint()

        elif factor_no == 4:
            self.dlg.FIF_status.setText("Processing Complete!")
            self.dlg.FIF_status.repaint()

        elif factor_no == 5:
            self.dlg.WTP_status.setText("Processing Complete!")
            self.dlg.WTP_status.repaint()

    def wtpAggregate(self):
        '''
        This function is used in combination with the "ServiceArea" function. Due to women's travel patterns involving numerous locations and/or facilities a service area network analysis
        has to be conducted numerous times. This function aggregates each of the service area analysis relating to women's travel patterns into a single standardized raster file.

        Factors it is applied:
            Accessibility Dimension
                - Women's Travel Patterns
        '''
        self.dlg.WTPAGG_status.setText("")
        self.dlg.WTPAGG_status.repaint()
        # OUTPUT
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Accessibility"
        WTP_Folder = f"{Dimension}/WTP"

        if os.path.exists(WTP_Folder):
            os.chdir(WTP_Folder)
        else:
            pass

        rasOutput = self.dlg.WTP_AGGOutput_Field.text()

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        tif_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.tif')]
        raster_list = []

        for ras in tif_list:
            with rasterio.open(ras) as src:
                raster_list.append(src.read(1))
                meta1 = src.meta

        len_raster_list = len(raster_list)
        cumulative_sum = 0

        for i in range(len_raster_list):
            value = raster_list[i]
            cumulative_sum += value

        aggregation = cumulative_sum / len_raster_list
        os.chdir("..")

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(aggregation, 1)

        self.dlg.WTP_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.WTPAGG_status.setText("Processing Complete!")
        self.dlg.WTPAGG_status.repaint()

        os.chdir(workingDir)

    def secAggregate(self):
        '''
        This function is used in combination with the "Rasterization" function. Due to security, or lack thereof, involving numerous incident types, rasterization of each type
        has to be conducted. This function aggregates each of the rasterized incident types relating to security into a single standardized raster file.

        Factors it is applied:
            Place Characterization Dimension
                - Security
        '''
        self.dlg.SECAGG_status.setText("")
        self.dlg.SECAGG_status.repaint()
        # OUTPUT
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Place Characterization"
        SEC_Folder = f"{Dimension}/SEC"

        if os.path.exists(SEC_Folder):
            os.chdir(SEC_Folder)
        else:
            pass

        rasOutput = self.dlg.SEC_AGGOutput_Field.text()

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        tif_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.tif')]
        raster_list = []

        for ras in tif_list:
            with rasterio.open(ras) as src:
                raster_list.append(src.read(1))
                meta1 = src.meta

        len_raster_list = len(raster_list)
        cumulative_sum = 0

        for i in range(len_raster_list):
            value = raster_list[i]
            cumulative_sum += value

        aggregation = cumulative_sum / len_raster_list
        os.chdir("..")

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(aggregation, 1)

        self.dlg.SEC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.SECAGG_status.setText("Processing Complete!")
        self.dlg.SECAGG_status.repaint()

        os.chdir(workingDir)

    def walkability(self):
        '''
        This function is used in combination with the "TypeSet" and "uniqueValue" functions to execute the Active Transports rasterization algorithm.
        It buffers the road network by 250m and rasterizes the buffer polygons according to the scoring assigned to the unique values.

        Factors it is applied:
            Place Characterization Dimension
                - Active Transport
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        lineLayer = self.dlg.WLK_Input_Field.filePath()
        roadTypeField = self.dlg.WLK_roadTypeField_CB.currentText()
        roadType_Score = ast.literal_eval(self.dlg.WLK_typeScore_Field.text())
        rasField = "Score"

        self.dlg.WLK_status.setText("Variables Set")
        self.dlg.WLK_status.repaint()
        time.sleep(0.5)
        self.dlg.WLK_status.setText("Processing...")
        self.dlg.WLK_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        scoredRoads = f"{workingDir}/{tempDir}/Scored_roads.shp"

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        self.convertCRS(lineLayer, UTM_crs)
        shp_utm[rasField] = ''


        for i in roadType_Score:
            shp_utm.loc[shp_utm[roadTypeField] == i[0], 'Score'] = i[1]

        shp_utm[rasField] = shp_utm[rasField].astype(int)
        shp_utm.to_file(scoredRoads)

        # scoredRoadsUTM = QgsVectorLayer(shp_utm.to_json(), "linebufUTM", "ogr")
        roadBuf_out = f"{workingDir}/{tempDir}/roadBuf.shp"

        self.dlg.WLK_status.setText("Processing... this may take a few minutes.")
        self.dlg.WLK_status.repaint()

        Buffer = processing.run("gdal:buffervectors",{'INPUT': scoredRoads,
                                             'GEOMETRY': 'geometry',
                                             'DISTANCE': 250,
                                             'FIELD': roadTypeField,
                                             'DISSOLVE': False,
                                             'EXPLODE_COLLECTIONS': False,
                                             'OPTIONS': '',
                                             'OUTPUT': roadBuf_out})

        dif_out = f"{workingDir}/{tempDir}/Dif.shp"

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': roadBuf_out,
                                                          'OUTPUT': dif_out,
                                                          'GRID_SIZE': None})

        # difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [roadBuf_out, dif_out],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        # Get the width and height of the extent
        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)
        rasOutput = self.dlg.WLK_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.WLK_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.WLK_status.setText("Processing Complete!")
        self.dlg.WLK_status.repaint()

    def SAFnightTimeLights(self):
        '''
        This function use a linearly scales the night time lights raster dataset according to the standardized scoring system.
        How brightly lit an area is is used as a proxy for safety or safe urban design.

        Factors it is applied:
            Place Characterization Dimension
                - Safe Urban Design
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        NTL_input = self.dlg.SAF_Input_Field.filePath()
        rasOutput = self.dlg.SAF_Output_Field.text()

        #Temp files
        tempCalc = f"{tempDir}/tempCalc.tif"
        tempResample = f"{tempDir}/tempResample.tif"
        countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuf.shp"

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.SAF_status.setText("Variables Set")
        self.dlg.SAF_status.repaint()
        time.sleep(0.5)
        self.dlg.SAF_status.setText("Processing...")
        self.dlg.SAF_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': countryUTMLayerBuf})

        # countryUTMLayerBuf = buffer["OUTPUT"]


        CountryBuf_df = gpd.read_file(countryUTMLayerBuf)
        country_extent = CountryBuf_df.total_bounds

        processing.run("gdal:warpreproject", {
            'INPUT': NTL_input,
            'SOURCE_CRS': None,
            'TARGET_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'RESAMPLING': 0,
            'NODATA': None,
            'TARGET_RESOLUTION': pixelSize,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'TARGET_EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
            'TARGET_EXTENT_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'MULTITHREADING': False,
            'EXTRA': '',
            'OUTPUT': tempResample})

        processing.run("gdal:rastercalculator", {
            'INPUT_A': tempResample,
            'BAND_A': 1, 'INPUT_B': None, 'BAND_B': None,
            'INPUT_C': None, 'BAND_C': None,
            'INPUT_D': None, 'BAND_D': None,
            'INPUT_E': None, 'BAND_E': None,
            'INPUT_F': None, 'BAND_F': None,
            'FORMULA': 'A*1000',
            'NO_DATA': None, 'EXTENT_OPT': 0, 'PROJWIN': None, 'RTYPE': 4, 'OPTIONS': '', 'EXTRA': '',
            'OUTPUT': tempCalc})

        with rasterio.open(tempCalc,'r+') as src:
            SAF_ras = src.read(1)
            meta1 = src.meta

            Rmax = SAF_ras.max()
            Rmin = SAF_ras.min()
            m_max = 5
            m_min = 0

        result = ((SAF_ras - Rmin)/(Rmax - Rmin)) * m_max
        meta1.update(dtype=rasterio.float32)

        if os.path.exists(Dimension):
            os.chdir(Dimension)
        else:
            os.mkdir(Dimension)
            os.chdir(Dimension)

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(result, 1)

        self.dlg.SAF_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        self.dlg.SAF_status.setText("Processing Complete!")
        self.dlg.SAF_status.repaint()

        os.chdir(workingDir)

    def ELCnightTimeLights(self):
        '''
        This function use a linearly scales the night time lights raster dataset according to the standardized scoring system.
        How brightly lit an area is is used as a proxy ro electricty access.

        Factors it is applied:
            Place Characterization Dimension
                - Electrical Access
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        NTL_input = self.dlg.ELC_NTLInput_Field.filePath()
        rasOutput = self.dlg.ELC_NTLOutput_Field.text()

        #Temp files
        tempCalc = f"{tempDir}/tempCalc.tif"
        tempResample = f"{tempDir}/tempResample.tif"
        countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuf.shp"

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.ELCNTL_status.setText("Variables Set")
        self.dlg.ELCNTL_status.repaint()
        time.sleep(0.5)
        self.dlg.ELCNTL_status.setText("Processing...")
        self.dlg.ELCNTL_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': countryUTMLayerBuf})

        # countryUTMLayerBuf = buffer["OUTPUT"]


        CountryBuf_df = gpd.read_file(countryUTMLayerBuf)
        country_extent = CountryBuf_df.total_bounds

        processing.run("gdal:warpreproject", {
            'INPUT': NTL_input,
            'SOURCE_CRS': None,
            'TARGET_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'RESAMPLING': 0,
            'NODATA': None,
            'TARGET_RESOLUTION': pixelSize,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'TARGET_EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
            'TARGET_EXTENT_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'MULTITHREADING': False,
            'EXTRA': '',
            'OUTPUT': tempResample})

        processing.run("gdal:rastercalculator", {
            'INPUT_A': tempResample,
            'BAND_A': 1, 'INPUT_B': None, 'BAND_B': None,
            'INPUT_C': None, 'BAND_C': None,
            'INPUT_D': None, 'BAND_D': None,
            'INPUT_E': None, 'BAND_E': None,
            'INPUT_F': None, 'BAND_F': None,
            'FORMULA': 'A*1000',
            'NO_DATA': None, 'EXTENT_OPT': 0, 'PROJWIN': None, 'RTYPE': 4, 'OPTIONS': '', 'EXTRA': '',
            'OUTPUT': tempCalc})

        with rasterio.open(tempCalc,'r+') as src:
            ELC_ras = src.read(1)
            meta1 = src.meta

            Rmax = ELC_ras.max()
            Rmin = ELC_ras.min()
            m_max = 5
            m_min = 0

        result = ((ELC_ras - Rmin)/(Rmax - Rmin)) * m_max
        meta1.update(dtype=rasterio.float32)

        if os.path.exists(Dimension):
            os.chdir(Dimension)
        else:
            os.mkdir(Dimension)
            os.chdir(Dimension)

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(result, 1)

        self.dlg.ELC_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        self.dlg.ELCNTL_status.setText("Processing Complete!")
        self.dlg.ELCNTL_status.repaint()

        os.chdir(workingDir)

    def transportCount(self):
        '''
        This algorithm characterizes areas based on the number of public transport options available. The algorithm overlays the input point layer onto a hexagonal grid
        and calculates the count of transport stops within each hexagonal cell. The output is standardized on a scale of 0 to 5 using a linear scaling process such that the
        cells containing the highest count of public transport stops are assigned a score of 5, and cells with no stops are assigned a score of 0. Finally, the output is rasterized.
        grid

        Factors it is applied:
            Place Characterization Dimension
                - Availability of Public Transport
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        hexSize = self.dlg.APT_hexSize_SB.value()
        pointLayer = self.dlg.APT_pointInput_Field.filePath()

        rasField = "Score"

        #TempOutput
        pointCount_out = f"{tempDir}/pointCountPoly.shp"
        adminUTMLayer = f"{tempDir}/adminUTMLayer.shp"
        pointUTMLayer = f"{tempDir}/pointUTMLayer.shp"
        pointCount_std = f"{tempDir}/pointCount_std.shp"

        self.dlg.APT_status.setText("Variables Set")
        self.dlg.APT_status.repaint()
        time.sleep(0.5)
        self.dlg.APT_status.setText("Processing...")
        self.dlg.APT_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]


        country_extent = shp_utm.total_bounds


        Grid = processing.run("native:creategrid", {'TYPE': 4, 'EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
                                                    'HSPACING': hexSize, 'VSPACING': hexSize, 'HOVERLAY': 0, 'VOVERLAY': 0,
                                                    'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
                                                    'OUTPUT': "memory:"})
        grid_out = Grid["OUTPUT"]

        Clip = processing.run("native:clip", {'INPUT': grid_out,
                                                'OVERLAY': countryUTMLayer,
                                                'OUTPUT': adminUTMLayer})

        self.convertCRS(pointLayer, UTM_crs)
        shp_utm.to_file(pointUTMLayer)


        pointCount = processing.run("native:countpointsinpolygon",{'POLYGONS': QgsProcessingFeatureSourceDefinition(adminUTMLayer,
                                                                   selectedFeaturesOnly = False,
                                                                   featureLimit = -1,
                                                                   flags = QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                                   geometryCheck = QgsFeatureRequest.GeometrySkipInvalid),
                                                                  'POINTS': pointUTMLayer,
                                                                  'WEIGHT': '',
                                                                  'CLASSFIELD': '',
                                                                  'FIELD': rasField,
                                                                  'OUTPUT': pointCount_out})


        pointCount_out_df = gpd.read_file(pointCount_out)

        Rmax = pointCount_out_df[rasField].max()
        Rmin = pointCount_out_df[rasField].min()
        m_max = 5
        m_min = 0

        pointCount_out_df[rasField] = (pointCount_out_df[rasField] - Rmin) / (Rmax - Rmin) * m_max
        pointCount_out_df.to_file(pointCount_std)

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': pointCount_std,
                                                          'OUTPUT': "memory:",
                                                          'GRID_SIZE': None})

        difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [pointCount_std, difference],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)

        rasOutput = self.dlg.APT_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.APT_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.APT_status.setText("Processing Complete!")
        self.dlg.APT_status.repaint()

        os.chdir(workingDir)

    def urbanization(self):
        '''
        This algorithm characterizes areas based on their degree of urbanization. The algorithm reclassifies the eight
        classes in the input data into classes ranging from 0 to 5 as per the standardized scoring system.

        Factors it is applied:
            Place Characterization Dimension
                - Level of Urbanization
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]

        LOU_input = self.dlg.LOU_Input_Field.filePath()
        rasOutput = self.dlg.LOU_Output_Field.text()
        rasField = "Score"

        #Temp Files
        tempRas = f"{tempDir}/RasReproj.tif"
        tempVect = f"{tempDir}/tempVect.shp"
        Dissolve = f"{tempDir}/Dissolve.shp"
        DisReclass = f"{tempDir}/DisReclass.shp"

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.LOU_status.setText("Variables Set")
        self.dlg.LOU_status.repaint()
        time.sleep(0.5)
        self.dlg.LOU_status.setText("Processing...")
        self.dlg.LOU_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        Reproject = processing.run("gdal:warpreproject", {'INPUT':LOU_input,
                                                           'SOURCE_CRS':None,
                                                           'TARGET_CRS':QgsCoordinateReferenceSystem(UTM_crs),
                                                           'RESAMPLING':0,
                                                           'NODATA':None,
                                                           'TARGET_RESOLUTION':None,
                                                           'OPTIONS':'',
                                                           'DATA_TYPE':0,
                                                           'TARGET_EXTENT':None,
                                                           'TARGET_EXTENT_CRS':None,
                                                           'MULTITHREADING':False,
                                                           'EXTRA':'',
                                                           'OUTPUT': tempRas})


        vector = processing.run("gdal:polygonize", {'INPUT': tempRas,
                                           'BAND': 1,
                                           'FIELD': 'DN',
                                           'EIGHT_CONNECTEDNESS': False,
                                           'EXTRA': '',
                                           'OUTPUT': tempVect})

        time.sleep(0.5)

        dissolve = processing.run("native:dissolve", {'INPUT': tempVect,
                                                      'FIELD':["DN"],
                                                      'SEPARATE_DISJOINT': False,
                                                      'OUTPUT': Dissolve})


        time.sleep(0.5)

        GHS_df = gpd.read_file(Dissolve)
        GHS_df["Score"] = 0
        GHS_df["Score"] = GHS_df["Score"].astype(int)

        conditions = [
            (GHS_df["DN"] == 30),
            (GHS_df["DN"] == 23),
            (GHS_df["DN"] == 22),
            (GHS_df["DN"] == 21),
            (GHS_df["DN"] == 13),
            (GHS_df["DN"] == 12),
            (GHS_df["DN"] == 11),
            (GHS_df["DN"] == 10)
        ]

        values = [5, 4, 3, 3, 2, 1, 1, 0]
        GHS_df["Score"] = np.select(conditions, values)

        GHS_vec = QgsVectorLayer(GHS_df.to_json(), "GHS_vec", "ogr")

        Clip = processing.run("native:clip", {'INPUT': GHS_vec,
                                              'OVERLAY': countryUTMLayerBuf,
                                              'OUTPUT': "memory:"})

        Clip_out = Clip["OUTPUT"]

        extent = Clip_out.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)
        rasOutput = self.dlg.LOU_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': Clip_out,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})
        
        self.dlg.LOU_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        self.dlg.LOU_status.setText("Processing Complete!")
        self.dlg.LOU_status.repaint()

    def housing(self):
        '''
        This function characterizes areas based on the size of housing and assumes that buildings with a footprint of less than 60 m2 are more likely to represent informal housing typologies.
        algorithm calculates the area of each building footprint in the input layer. It then overlays the input layer onto a hexagonal grid and calculates the percentage
        of buildings within each hexagonal cell with a footprint greater than 60 m2.

        The output produced is a raster file containing values ranging from 0 to 5 is saved to the output directory. In this scale,
        5 signifies areas where 100% of buildings have a footprint larger than 60 m2 (and can be interpreted as entirely formal settlements),
        while 0 indicates areas where no buildings possess a footprint larger than 60 m2 (and can be interpreted as entirely informal settlements).

        Factors it is applied:
            Place Characterization Dimension
                - Size of Housing
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        hexSize = self.dlg.QUH_hexSize_SB.value()
        buildingFootprints = self.dlg.QUH_Input_Field.filePath()
        rasField = "Perc"

        # TempFiles
        scoredRoads = f"{workingDir}/{tempDir}/Scored_roads.shp"
        adminUTMLayer = f"{tempDir}/adminUTMLayer.shp"
        buildingOutput = f"{tempDir}/buildingOutput.shp"
        hexPercOutput = f"{tempDir}/hexPercOutput.shp"
        hexRasOutput = f"{tempDir}/hexRasOutput.tif"
        zonalOutput = f"{tempDir}/zonalOutput.shp"
        buildingFootprintsUTM = f"{tempDir}/buildingFootprintsUTM.shp"

        self.dlg.QUH_status.setText("Variables Set")
        self.dlg.QUH_status.repaint()
        time.sleep(0.5)
        self.dlg.QUH_status.setText("Processing...")
        self.dlg.QUH_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        country_extent = shp_utm.total_bounds

        Grid = processing.run("native:creategrid", {'TYPE': 4,
                                                    'EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
                                                    'HSPACING': hexSize, 'VSPACING': hexSize, 'HOVERLAY': 0,
                                                    'VOVERLAY': 0,
                                                    'CRS': QgsCoordinateReferenceSystem(f'{UTM_crs}'),
                                                    'OUTPUT': "memory:"})
        grid_out = Grid["OUTPUT"]

        Clip = processing.run("native:clip", {'INPUT': grid_out,
                                              'OVERLAY': countryUTMLayer,
                                              'OUTPUT': "memory:"})

        clip_out = Clip["OUTPUT"]

        #Rasterize hexegons
        extent = clip_out.extent()
        raster_width = int(extent.width() / (pixelSize/10))
        raster_height = int(extent.height() / (pixelSize))

        rasterize = processing.run("gdal:rasterize", {'INPUT': clip_out,
                                                      'FIELD': "id",
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': hexRasOutput})

        self.convertCRS(buildingFootprints, UTM_crs)
        shp_utm.to_file(buildingFootprintsUTM)

        #Zonal Statistics using majority

        zonal =  processing.run("native:zonalstatisticsfb", {'INPUT':QgsProcessingFeatureSourceDefinition(buildingFootprintsUTM,
                                                                                                          selectedFeaturesOnly=False,
                                                                                                          featureLimit=-1,
                                                                                                          flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                                                                          geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                                             'INPUT_RASTER':hexRasOutput,
                                                             'RASTER_BAND':1,
                                                             'COLUMN_PREFIX':'_',
                                                             'STATISTICS':[9],
                                                             'OUTPUT':zonalOutput})


        Clip = processing.run("native:clip", {'INPUT': grid_out,
                                              'OVERLAY': countryUTMLayer,
                                              'OUTPUT': adminUTMLayer})

        BF_gdf = gpd.read_file(zonalOutput)
        Admin_gdf = gpd.read_file(adminUTMLayer)
        BF_gdf = gpd.overlay(Admin_gdf, BF_gdf, how='intersection')

        building_geometries = BF_gdf['geometry']
        BF_gdf['Area'] = building_geometries.area
        BF_gdf['more_60'] = 0
        BF_gdf.loc[BF_gdf['Area'] > 60, 'more_60'] = 1
        BF_gdf['id'] = BF_gdf['_majority'].astype(int)
        BF_gdf.to_file(buildingOutput)

        grouped = BF_gdf.groupby('id').size().reset_index(name='Total_Count')

        filtered_df = BF_gdf[BF_gdf['more_60'] == 1]

        grouped2 = filtered_df.groupby('id').size().reset_index(name='More60_Count')

        merged = pd.merge(grouped, grouped2, on=['id'], how='outer')
        merged_length_gdf = pd.DataFrame(merged)
        merged_length_gdf[rasField] = merged_length_gdf["More60_Count"] / merged_length_gdf["Total_Count"] * 100

        hex_gdf = gpd.read_file(adminUTMLayer)
        merge_hex_gdf = hex_gdf.merge(merged_length_gdf, on='id', how='outer')
        # merge_hex_gdf.to_file(FinalHexOutput)

        # Rasterization

        Rmax = 100
        Rmin = 0
        m_max = 5
        m_min = 0

        merge_hex_gdf[rasField] = (merge_hex_gdf[rasField] - Rmin) / (Rmax - Rmin) * m_max
        merge_hex_gdf.to_file(hexPercOutput)

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': hexPercOutput,
                                                          'OUTPUT': "memory:",
                                                          'GRID_SIZE': None})

        difference = Difference["OUTPUT"]

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [hexPercOutput, difference],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        extent = mergeOutput.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        os.chdir(Dimension)

        rasOutput = self.dlg.QUH_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.QUH_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.QUH_status.setText("Processing Complete!")
        self.dlg.QUH_status.repaint()

    def natEnvironment(self):
        '''
        This function is used in combination with the "TypeSet" and "uniqueValues" functions to execute the Natural Environment and Climatic factors algorithm.
        The input layers are rasterized according to the scoring assigned to the unique hazard values.

        Factors it is applied:
            Place Characterization Dimension
                - Natural Environment and Climatic factors
        '''
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        tempDir = "temp"
        Dimension = "Place Characterization"

        if os.path.exists(Dimension):
            pass
        else:
            os.mkdir(Dimension)

        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        polygonLayer = self.dlg.ENV_Input_Field.filePath()
        riskLevelField = self.dlg.ENV_riskLevelField_CB.currentText()
        riskType_Score = ast.literal_eval(self.dlg.ENV_typeScore_Field.text())
        rasField = "Score"

        self.dlg.ENV_status.setText("Variables Set")
        self.dlg.ENV_status.repaint()
        time.sleep(0.5)
        self.dlg.ENV_status.setText("Processing...")
        self.dlg.ENV_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm[rasField] = [0]
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        scoredRisks = f"{workingDir}/{tempDir}/Scored_risks.shp"

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': "memory:"})

        countryUTMLayerBuf = buffer["OUTPUT"]

        self.convertCRS(polygonLayer, UTM_crs)
        shp_utm[rasField] = 0

        for i in riskType_Score:
            # QMessageBox.information(self.dlg, "Message", f"{i}")
            shp_utm.loc[shp_utm[riskLevelField] == i[0], 'Score'] = i[1]

        shp_utm[rasField] = shp_utm[rasField].astype(int)
        shp_utm.to_file(scoredRisks)

        dif_out = f"{workingDir}/{tempDir}/Dif.shp"

        Difference = processing.run("native:difference", {'INPUT': countryUTMLayerBuf,
                                                          'OVERLAY': QgsProcessingFeatureSourceDefinition(scoredRisks,
                                                                                                         selectedFeaturesOnly=False, featureLimit=-1,
                                                                                                         flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                                                                         geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                                          'OUTPUT': dif_out,
                                                          'GRID_SIZE': None})

        Merge = processing.run("native:mergevectorlayers", {'LAYERS': [scoredRisks, dif_out],
                                                            'CRS': None,
                                                            'OUTPUT': "memory:"})

        mergeOutput = Merge["OUTPUT"]

        # Get the width and height of the extent
        extent = countryUTMLayerBuf.extent()
        raster_width = int(extent.width() / pixelSize)
        raster_height = int(extent.height() / pixelSize)

        if os.path.exists(Dimension):
            os.chdir(Dimension)
        else:
            os.mkdir(Dimension)
            os.chdir(Dimension)

        Output_Folder = "ENV"
        if os.path.exists(Output_Folder):
            os.chdir(Output_Folder)
        else:
            os.mkdir(Output_Folder)
            os.chdir(Output_Folder)

        rasOutput = self.dlg.ENV_Output_Field.text()

        rasterize = processing.run("gdal:rasterize", {'INPUT': mergeOutput,
                                                      'FIELD': rasField,
                                                      'BURN': 0,
                                                      'USE_Z': False,
                                                      'UNITS': 0,
                                                      'WIDTH': raster_width,
                                                      'HEIGHT': raster_height,
                                                      'EXTENT': None,
                                                      'NODATA': None,
                                                      'OPTIONS': '',
                                                      'DATA_TYPE': 5,
                                                      'INIT': None,
                                                      'INVERT': False,
                                                      'EXTRA': '',
                                                      'OUTPUT': rasOutput})

        self.dlg.ENV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/{Output_Folder}"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.ENV_status.setText("Processing Complete!")
        self.dlg.ENV_status.repaint()

    def envAggregate(self):
        '''
        This function is used in combination with the "natEnvironment" function. Due to there being numerous Natural Environment and Climatic factors that could
        influence place characterization the rasterization and standardization has to be conducted for each hazard. This function aggregates each of the hazards
        relating to Natural Environment and Climatic factors into a single standardized raster file.

        Factors it is applied:
            Accessibility Dimension
                - Natural Environment and Climatic factors
        '''
        # OUTPUT
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)
        Dimension = "Place Characterization"
        ENV_Folder = f"{Dimension}/ENV"

        if os.path.exists(ENV_Folder):
            os.chdir(ENV_Folder)
        else:
            pass

        rasOutput = self.dlg.ENV_AGGOutput_Field.text()

        styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
        styleFileDestination = f"{workingDir}{Dimension}/"
        styleFile = f"{rasOutput.split('.')[0]}.qml"

        self.dlg.ENVAGG_status.setText("Variables Set")
        self.dlg.ENVAGG_status.repaint()
        time.sleep(0.5)
        self.dlg.ENVAGG_status.setText("Processing...")
        self.dlg.ENVAGG_status.repaint()

        tif_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.tif')]
        raster_list = []

        for ras in tif_list:
            with rasterio.open(ras) as src:
                raster_list.append(src.read(1))
                meta1 = src.meta

        len_raster_list = len(raster_list)
        cumulative_sum = 0

        for i in range(len_raster_list):
            value = raster_list[i]
            cumulative_sum += value

        aggregation = cumulative_sum / len_raster_list
        os.chdir("..")

        with rasterio.open(rasOutput, 'w', **meta1) as dst:
            dst.write(aggregation, 1)

        self.dlg.ENV_Aggregate_Field.setText(f"{workingDir}{Dimension}/{rasOutput}")

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.ENVAGG_status.setText("Processing Complete!")
        self.dlg.ENVAGG_status.repaint()

    # *************************** Factor Aggregation Functions ************************************ #
    def indivdualAggregation(self):
        '''
        This function performs a raster calculation aggregating all the individual dimension factors according to their weightings
        '''
        self.dlg.individualAggregation_Check.setText("")
        self.dlg.individualAggregation_Check.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        #INPUT

        EDU_ras = self.dlg.EDU_Aggregate_Field.text().strip(" ")
        CRE_ras = self.dlg.CRE_Aggregate_Field.text().strip(" ")
        DOV_ras = self.dlg.DOV_Aggregate_Field.text().strip(" ")

        EDU_weight = self.dlg.EDU_Aggregate_SB.value()
        CRE_weight = self.dlg.CRE_Aggregate_SB.value()
        DOV_weight = self.dlg.DOV_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Indivdual_AggregateOutput_Field.text()

        rasLayers = [EDU_ras, CRE_ras, DOV_ras]
        factorWeighting = [EDU_weight, CRE_weight, DOV_weight]

        non_empty_count = sum(1 for item in rasLayers if item != "")

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:
                with rasterio.open(rasLayers[0]) as src:
                    EDU_ras = src.read(1)
                    EDU_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CRE_ras = src.read(1)
                    CRE_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    DOV_ras = src.read(1)
                    DOV_weight = factorWeighting[2]

                # Raster Calculation

                result = ((EDU_ras * EDU_weight / 100) + (CRE_ras * CRE_weight / 100) + (DOV_ras * DOV_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Individual"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.ID_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerID = logging.getLogger('loggerID')
                loggerID.setLevel(logging.INFO)
                handlerID = logging.FileHandler('Individual.log')
                formatterID = logging.Formatter('%(asctime)s - %(message)s')
                handlerID.setFormatter(formatterID)
                loggerID.addHandler(handlerID)

                loggerID.info(f"Factors: {non_empty_count}/3 - {non_empty_count/3 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                self.dlg.individualAggregation_Check.setText("Individual dimension aggregation complete!")
            else:
                self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.individualAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def contextualAggregation(self):
        '''
        This function performs a raster calculation aggregating all the contextual dimension factors according to their weightings
        '''
        self.dlg.contextualAggregation_Check.setText("")
        self.dlg.contextualAggregation_Check.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        PLP_ras = self.dlg.PLP_Aggregate_Field.text().strip(" ")
        FIN_ras = self.dlg.FIN_Aggregate_Field.text().strip(" ")

        PLP_weight = self.dlg.PLP_Aggregate_SB.value()
        FIN_weight = self.dlg.FIN_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Contextual_AggregateOutput_Field.text()

        rasLayers = [PLP_ras, FIN_ras]
        factorWeighting = [PLP_weight, FIN_weight]
        non_empty_count = sum(1 for item in rasLayers if item != "")

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    PLP_ras = src.read(1)
                    PLP_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    FIN_ras = src.read(1)
                    FIN_weight = factorWeighting[1]


                # Raster Calculation

                result = ((PLP_ras * PLP_weight / 100) + (FIN_ras * FIN_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Contextual"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.CD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerCD = logging.getLogger('loggerCD')
                loggerCD.setLevel(logging.INFO)
                handlerCD = logging.FileHandler('Contextual.log')
                formatterCD = logging.Formatter('%(asctime)s - %(message)s')
                handlerCD.setFormatter(formatterCD)
                loggerCD.addHandler(handlerCD)

                loggerCD.info(f"Factors: {non_empty_count}/2 - {non_empty_count/2 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                time.sleep(1)

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                self.dlg.contextualAggregation_Check.setText("Contextual dimension aggregation complete!")
            else:
                self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.contextualAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def accessibiltyAggregation(self):
        '''
        This function performs a raster calculation aggregating all the accessibilty dimension factors according to their weightings
        '''
        self.dlg.accessibilityAggregation_Check.setText("")
        self.dlg.accessibilityAggregation_Check.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        #INPUT
        WTP_ras = self.dlg.WTP_Aggregate_Field.text().strip(" ")
        PBT_ras = self.dlg.PBT_Aggregate_Field.text().strip(" ")
        ETF_ras = self.dlg.ETF_Aggregate_Field.text().strip(" ")
        JOB_ras = self.dlg.JOB_Aggregate_Field.text().strip(" ")
        HEA_ras = self.dlg.HEA_Aggregate_Field.text().strip(" ")
        FIF_ras = self.dlg.FIF_Aggregate_Field.text().strip(" ")

        WTP_weight = self.dlg.WTP_Aggregate_SB.value()
        PBT_weight = self.dlg.PBT_Aggregate_SB.value()
        ETF_weight = self.dlg.ETF_Aggregate_SB.value()
        JOB_weight = self.dlg.JOB_Aggregate_SB.value()
        HEA_weight = self.dlg.HEA_Aggregate_SB.value()
        FIF_weight = self.dlg.FIF_Aggregate_SB.value()

        #OUTPUT
        aggregation = self.dlg.Accessibility_AggregateOutput_Field.text()

        rasLayers = [WTP_ras, PBT_ras, ETF_ras, JOB_ras, HEA_ras, FIF_ras]
        factorWeighting = [WTP_weight, PBT_weight, ETF_weight, JOB_weight, HEA_weight, FIF_weight]
        non_empty_count = sum(1 for item in rasLayers if item != "")

        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:
                with rasterio.open(rasLayers[0]) as src:
                    WTP_ras = src.read(1)
                    WTP_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    PBT_ras = src.read(1)
                    PBT_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    ETF_ras = src.read(1)
                    ETF_weight = factorWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    JOB_ras = src.read(1)
                    JOB_weight = factorWeighting[3]

                with rasterio.open(rasLayers[4]) as src:
                    HEA_ras = src.read(1)
                    HEA_weight = factorWeighting[4]

                with rasterio.open(rasLayers[5]) as src:
                    FIF_ras = src.read(1)
                    FIF_weight = factorWeighting[5]

                # Raster Calculation

                result = ((WTP_ras * WTP_weight / 100) + (PBT_ras * PBT_weight / 100) + (ETF_ras * ETF_weight / 100)
                          + (JOB_ras * JOB_weight / 100) + (HEA_ras * HEA_weight / 100) + (FIF_ras * FIF_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Accessibility"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.AD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerAD = logging.getLogger('loggerAD')
                loggerAD.setLevel(logging.INFO)
                handlerAD = logging.FileHandler('Accessibility.log')
                formatterAD = logging.Formatter('%(asctime)s - %(message)s')
                handlerAD.setFormatter(formatterAD)
                loggerAD.addHandler(handlerAD)

                loggerAD.info(f"Factors: {non_empty_count}/6 - {non_empty_count/6 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                self.dlg.accessibilityAggregation_Check.setText("Accessibility dimension aggregation complete!")
            else:
                self.dlg.accessibilityAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.accessibilityAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def placeCharacterizationAggregation(self):
        '''
        This function performs a raster calculation aggregating all the place characterization dimension factors according to their weightings
        '''
        self.dlg.placeCharacterizationAggregation_Check.setText("")
        self.dlg.placeCharacterizationAggregation_Check.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        WLK_ras = self.dlg.WLK_Aggregate_Field.text().strip(" ")
        # CYC_ras = self.dlg.CYC_Aggregate_Field.text().strip(" ")
        APT_ras = self.dlg.APT_Aggregate_Field.text().strip(" ")
        SAF_ras = self.dlg.SAF_Aggregate_Field.text().strip(" ")
        SEC_ras = self.dlg.SEC_Aggregate_Field.text().strip(" ")
        INC_ras = self.dlg.INC_Aggregate_Field.text().strip(" ")
        ELC_ras = self.dlg.ELC_Aggregate_Field.text().strip(" ")
        LOU_ras = self.dlg.LOU_Aggregate_Field.text().strip(" ")
        QUH_ras = self.dlg.QUH_Aggregate_Field.text().strip(" ")
        DIG_ras = self.dlg.DIG_Aggregate_Field.text().strip(" ")
        ENV_ras = self.dlg.ENV_Aggregate_Field.text().strip(" ")

        WLK_weight = self.dlg.WLK_Aggregate_SB.value()
        # CYC_weight = self.dlg.CYC_Aggregate_SB.value()
        APT_weight = self.dlg.APT_Aggregate_SB.value()
        SAF_weight = self.dlg.SAF_Aggregate_SB.value()
        SEC_weight = self.dlg.SEC_Aggregate_SB.value()
        INC_weight = self.dlg.INC_Aggregate_SB.value()
        ELC_weight = self.dlg.ELC_Aggregate_SB.value()
        LOU_weight = self.dlg.LOU_Aggregate_SB.value()
        QUH_weight = self.dlg.QUH_Aggregate_SB.value()
        DIG_weight = self.dlg.DIG_Aggregate_SB.value()
        ENV_weight = self.dlg.ENV_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.PlaceCharacterization_AggregateOutput_Field.text()

        rasLayers = [WLK_ras, APT_ras, SAF_ras, SEC_ras, INC_ras, ELC_ras, LOU_ras, QUH_ras, DIG_ras, ENV_ras]
        factorWeighting = [WLK_weight, APT_weight, SAF_weight, SEC_weight, INC_weight, ELC_weight, LOU_weight, QUH_weight, DIG_weight, ENV_weight]
        non_empty_count = sum(1 for item in rasLayers if item != "")


        weightingSum = round(sum(factorWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    factorWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(factorWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    WLK_ras = src.read(1)
                    WLK_weight = factorWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    APT_ras = src.read(1)
                    APT_weight = factorWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    SAF_ras = src.read(1)
                    SAF_weight = factorWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    SEC_ras = src.read(1)
                    SEC_weight = factorWeighting[3]

                with rasterio.open(rasLayers[4]) as src:
                    INC_ras = src.read(1)
                    INC_weight = factorWeighting[4]

                with rasterio.open(rasLayers[5]) as src:
                    ELC_ras = src.read(1)
                    ELC_weight = factorWeighting[5]

                with rasterio.open(rasLayers[6]) as src:
                    LOU_ras = src.read(1)
                    LOU_weight = factorWeighting[6]

                with rasterio.open(rasLayers[7]) as src:
                    QUH_ras = src.read(1)
                    QUH_weight = factorWeighting[7]

                with rasterio.open(rasLayers[8]) as src:
                    DIG_ras = src.read(1)
                    DIG_weight = factorWeighting[8]

                with rasterio.open(rasLayers[9]) as src:
                    ENV_ras = src.read(1)
                    ENV_weight = factorWeighting[9]

                # Raster Calculation

                result = ((WLK_ras * WLK_weight / 100) + (APT_ras * APT_weight / 100)
                          + (SAF_ras * SAF_weight / 100) + (SEC_ras * SEC_weight / 100) + (INC_ras * INC_weight / 100)
                          + (ELC_ras * ELC_weight / 100) + (LOU_ras * LOU_weight / 100) + (QUH_ras * QUH_weight / 100)
                          + (DIG_ras * DIG_weight / 100) + (ENV_ras * ENV_weight / 100))

                meta1.update(dtype=rasterio.float32)

                Dimension = "Place Characterization"
                if os.path.exists(Dimension):
                    os.chdir(Dimension)
                else:
                    os.mkdir(Dimension)
                    os.chdir(Dimension)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                self.dlg.PD_Aggregate_Field.setText(f"{workingDir}{Dimension}/{aggregation}")

                loggerPD = logging.getLogger('loggerPD')
                loggerPD.setLevel(logging.INFO)
                handlerPD = logging.FileHandler('Place Characterization.log')
                formatterPD = logging.Formatter('%(asctime)s - %(message)s')
                handlerPD.setFormatter(formatterPD)
                loggerPD.addHandler(handlerPD)

                loggerPD.info(f"Factors: {non_empty_count}/10 - {non_empty_count / 10 * 100} % - {non_empty_count}")
                logging.shutdown()

                styleTemplate = f"{current_script_path}/Style/{Dimension}.qml"
                styleFileDestination = f"{workingDir}{Dimension}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                self.dlg.placeCharacterizationAggregation_Check.setText("Place Characterization dimension aggregation complete!")
            else:
                self.dlg.placeCharacterizationAggregation_Check.setText("Weighting % does not add up to 100 %")
        else:
            self.dlg.placeCharacterizationAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    def dimesnionsAggregation(self):
        '''
        This function performs a final raster calculation aggregating all the dimension aggregation output raster according to their weightings
        '''
        self.dlg.dimensionAggregation_Check.setText("")
        self.dlg.dimensionAggregation_Check.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()
        os.chdir(workingDir)

        # INPUT
        ID_ras = self.dlg.ID_Aggregate_Field.text().strip(" ")
        CD_ras = self.dlg.CD_Aggregate_Field.text().strip(" ")
        AD_ras = self.dlg.AD_Aggregate_Field.text().strip(" ")
        PD_ras = self.dlg.PD_Aggregate_Field.text().strip(" ")

        ID_weight = self.dlg.ID_Aggregate_SB.value()
        CD_weight = self.dlg.CD_Aggregate_SB.value()
        AD_weight = self.dlg.AD_Aggregate_SB.value()
        PD_weight = self.dlg.PD_Aggregate_SB.value()

        # OUTPUT
        aggregation = self.dlg.Dimensions_AggregateOutput_Field.text()

        rasLayers = [ID_ras, CD_ras, AD_ras, PD_ras]
        dimensionWeighting = [ID_weight, CD_weight, AD_weight, PD_weight]

        weightingSum = round(sum(dimensionWeighting))

        if weightingSum == 100:
            if "" in rasLayers:
                missingLayers = [index for index, item in enumerate(rasLayers) if item == ""]
                presentLayers = [index for index, item in enumerate(rasLayers) if item != ""]

                for i in missingLayers:
                    rasLayers[i] = rasLayers[presentLayers[0]]
                    dimensionWeighting[i] = 0

            else:
                pass

            weightingSum = round(sum(dimensionWeighting))
            if weightingSum == 100:

                with rasterio.open(rasLayers[0]) as src:
                    ID_ras = src.read(1)
                    ID_weight = dimensionWeighting[0]
                    meta1 = src.meta

                with rasterio.open(rasLayers[1]) as src:
                    CD_ras = src.read(1)
                    CD_weight = dimensionWeighting[1]

                with rasterio.open(rasLayers[2]) as src:
                    AD_ras = src.read(1)
                    AD_weight = dimensionWeighting[2]

                with rasterio.open(rasLayers[3]) as src:
                    PD_ras = src.read(1)
                    PD_weight = dimensionWeighting[3]



                # Raster Calculation

                result = ((ID_ras * ID_weight / 100) + (CD_ras * CD_weight / 100) + (AD_ras * AD_weight / 100) + (PD_ras * PD_weight / 100))
                result[result == 0] = src.nodata

                meta1.update(dtype=rasterio.float32)

                Final_output = "Final_output"
                if os.path.exists(Final_output):
                    os.chdir(Final_output)
                else:
                    os.mkdir(Final_output)
                    os.chdir(Final_output)

                with rasterio.open(aggregation, 'w', **meta1) as dst:
                    dst.write(result, 1)

                styleTemplate = f"{current_script_path}/Style/Final.qml"
                styleFileDestination = f"{workingDir}{Final_output}/"
                styleFile = f"{aggregation.split('.')[0]}.qml"

                shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

                log_list = ['Individual', 'Contextual', 'Accessibility', 'Place Characterization']
                factor_num = []

                for dimension in log_list:
                    log_file = f"{workingDir}{dimension}/{dimension}.log"
                    if os.path.exists(log_file):
                        with open(log_file, 'r') as file:
                            lines = file.readlines()

                            if lines:
                                last_line = lines[-1].split("-")[-1].strip()
                            else:
                                pass

                            factor_num.append(last_line)
                    else:
                        pass

                integer_list = [int(item) for item in factor_num]
                sum_list = sum(integer_list)
                Confidence = round(sum_list/21 * 100, 2)

                layer = QgsRasterLayer(aggregation, f"{aggregation}")

                if not layer.isValid():
                    print("Layer failed to load!")

                QgsProject.instance().addMapLayer(layer)

                self.dlg.FinalAggregation_Check.setText(f"Dimensional aggregation complete! - Confidence: {sum_list}/21 factors used. ({Confidence} %)")
            else:
                self.dlg.dimensionAggregation_Check.setText("Weighting % does not add up to 100 %")

        else:
            self.dlg.dimensionAggregation_Check.setText("Weighting % does not add up to 100 %")

        os.chdir(workingDir)

    # *************************** Insights Tab Functions *********************************** #
    def scoreReclassInsights(self):
        '''
        This function takes the final aggregate score, a dimension aggregate score, or even a single factor output raster and classifies it into five discrete classes of enablement.
        '''
        self.dlg.Enablement_status.setText("")
        self.dlg.Enablement_status.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()

        os.chdir(workingDir)
        Insights_folder = "Insights"
        if os.path.exists(Insights_folder):
            pass
        else:
            os.mkdir(Insights_folder)

        tempDir = f"temp"
        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        # INPUT
        score = self.dlg.Insights_Score_Input_Field.filePath()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()

        # Temp OUTPUT
        countryUTMLayer = f"{tempDir}/countryUTMLayer.shp"
        countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuf.shp"
        ScoretempResample = f"{tempDir}/ScoretempResample.tif"

        self.dlg.Enablement_status.setText("Variables Set")
        self.dlg.Enablement_status.repaint()

        self.dlg.Enablement_status.setText("Processing...")
        self.dlg.Enablement_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm.to_file(countryUTMLayer)

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': countryUTMLayerBuf})

        CountryBuf_df = gpd.read_file(countryUTMLayerBuf)
        country_extent = CountryBuf_df.total_bounds

        processing.run("gdal:warpreproject", {
            'INPUT': score,
            'SOURCE_CRS': None,
            'TARGET_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'RESAMPLING': 0,
            'NODATA': None,
            'TARGET_RESOLUTION': pixelSize,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'TARGET_EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
            'TARGET_EXTENT_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'MULTITHREADING': False,
            'EXTRA': '',
            'OUTPUT': ScoretempResample})


        Insights_enablement = "1) Level of Enablement Classification"
        if os.path.exists(f"{Insights_folder}/{Insights_enablement}"):
            pass
        else:
            os.mkdir(f"{Insights_folder}/{Insights_enablement}")

        # Score Reclassify
        with rasterio.open(ScoretempResample) as src:
            score_ras = src.read(1)
            meta1 = src.meta

        # Raster Calculation

        result = 0 * (score_ras <= 0.5) + 1 * (score_ras > 0.5) * (score_ras <= 1.5) + 2 * (score_ras > 1.5) * (
                    score_ras <= 2.5) + \
                 3 * (score_ras > 2.5) * (score_ras <= 3.5) + 4 * (score_ras > 3.5) * (score_ras <= 4.5) + 5 * (
                             score_ras > 4.5)

        meta1.update(dtype=rasterio.float32)

        score_rec = f"{workingDir}{Insights_folder}/{Insights_enablement}/Level_of_Enablement.tif"
        with rasterio.open(score_rec, 'w', **meta1) as dst:
            dst.write(result, 1)

        styleTemplate = f"{current_script_path}/Style/Insights Score.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_enablement}"
        styleFile = f"{score_rec.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.Insights_ScoreReclass_Input_Field.setFilePath(f"{score_rec}")

        self.dlg.Enablement_status.setText("Classification Complete!")
        self.dlg.Enablement_status.repaint()

    def populationReclassInsights(self):
        '''
        This function takes a population count raster as input and classifies it into 3 discrete classes based on
        the lower quartile range, interquartile range, and upper quartile range of data to identify
        areas of relatively low, medium, and high population per region.
        '''
        self.dlg.Population_status.setText("")
        self.dlg.Population_status.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()

        os.chdir(workingDir)
        Insights_folder = "Insights"
        if os.path.exists(Insights_folder):
            pass
        else:
            os.mkdir(Insights_folder)

        tempDir = f"temp"
        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        # INPUT
        population = self.dlg.Insights_Population_Input_Field.filePath()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()

        # Temp OUTPUT
        countryUTMLayer = f"{tempDir}/countryUTMLayer.shp"
        countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuf.shp"
        PoptempResample = f"{tempDir}/PoptempResample.tif"

        self.dlg.Population_status.setText("Variables Set")
        self.dlg.Population_status.repaint()

        self.dlg.Population_status.setText("Processing...")
        self.dlg.Population_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm.to_file(countryUTMLayer)

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': countryUTMLayerBuf})

        CountryBuf_df = gpd.read_file(countryUTMLayerBuf)
        country_extent = CountryBuf_df.total_bounds

        processing.run("gdal:warpreproject", {
            'INPUT': population,
            'SOURCE_CRS': None,
            'TARGET_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'RESAMPLING': 0,
            'NODATA': None,
            'TARGET_RESOLUTION': pixelSize,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'TARGET_EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
            'TARGET_EXTENT_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'MULTITHREADING': False,
            'EXTRA': '',
            'OUTPUT': PoptempResample})

        Insights_population = "2) Relative Population Count Classification"
        if os.path.exists(f"{Insights_folder}/{Insights_population}"):
            pass
        else:
            os.mkdir(f"{Insights_folder}/{Insights_population}")

        # Population Reclassify
        with rasterio.open(PoptempResample) as src:
            pop_ras = src.read(1)
            meta1 = src.meta

            pop_ras[pop_ras == src.nodata] = -1
            masked_raster = np.ma.masked_where(pop_ras == -1, pop_ras)

            # out_image, out_transform = np.ma.mask(masked_raster, countryUTMLayer, invert=True)

        percentile_25 = np.percentile(masked_raster.compressed(), 25)
        percentile_75 = np.percentile(masked_raster.compressed(), 75)

        # # Raster Calculation
        #
        result = 0 * (pop_ras == -1) + 1 * (pop_ras > -1) * (pop_ras <= percentile_25) + 2 * (pop_ras > percentile_25) * (pop_ras <= percentile_75) + 3 * (
                    pop_ras > percentile_75)

        # result = pop_ras

        meta1.update(dtype=rasterio.float32)

        pop_rec = f"{workingDir}{Insights_folder}/{Insights_population}/Relative_Population_Count.tif"
        with rasterio.open(pop_rec, 'w', **meta1) as dst:
            dst.write(result, 1)

        styleTemplate = f"{current_script_path}/Style/Insights Population.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_population}/"
        styleFile = f"{pop_rec.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.Insights_PopulationReclass_Input_Field.setFilePath(f"{pop_rec}")

        self.dlg.Population_status.setText("Classification Complete!")
        self.dlg.Population_status.repaint()

    def combineReclassInsights(self):
        '''
        Through the use of raster calculation this function combines the discrete level of enablement raster produced by the "scoreReclassInsights"
        function and the relative population count raster produced by the "populationReclassInsights" function. A single raster layer is produced
        contains 15 classes.
        '''
        self.dlg.Combine_status.setText("")
        self.dlg.Combine_status.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()

        os.chdir(workingDir)
        Insights_folder = "Insights"
        if os.path.exists(Insights_folder):
            pass
        else:
            os.mkdir(Insights_folder)

        tempDir = f"temp"
        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        # INPUT
        score_rec = self.dlg.Insights_ScoreReclass_Input_Field.filePath()
        pop_rec = self.dlg.Insights_PopulationReclass_Input_Field.filePath()

        Insights_combine = "3) Combined Level of Enablement & Relative Population Count Classification"
        if os.path.exists(f"{Insights_folder}/{Insights_combine}"):
            pass
        else:
            os.mkdir(f"{Insights_folder}/{Insights_combine}")

        self.dlg.Combine_status.setText("Variables Set")
        self.dlg.Combine_status.repaint()

        self.dlg.Combine_status.setText("Processing...")
        self.dlg.Combine_status.repaint()
    
        # Combine Population and Score Reclassify
        with rasterio.open(score_rec) as src:
            score_rec_ras = src.read(1)
            meta1 = src.meta

        with rasterio.open(pop_rec) as src:
            pop_rec_ras = src.read(1)

        # Raster Calculation

        result = \
            1 * (score_rec_ras == 1) * (pop_rec_ras == 1) + \
            2 * (score_rec_ras == 1) * (pop_rec_ras == 2) + \
            3 * (score_rec_ras == 1) * (pop_rec_ras == 3) + \
            4 * (score_rec_ras == 2) * (pop_rec_ras == 1) + \
            5 * (score_rec_ras == 2) * (pop_rec_ras == 2) + \
            6 * (score_rec_ras == 2) * (pop_rec_ras == 3) + \
            7 * (score_rec_ras == 3) * (pop_rec_ras == 1) + \
            8 * (score_rec_ras == 3) * (pop_rec_ras == 2) + \
            9 * (score_rec_ras == 3) * (pop_rec_ras == 3) + \
            10 * (score_rec_ras == 4) * (pop_rec_ras == 1) + \
            11 * (score_rec_ras == 4) * (pop_rec_ras == 2) + \
            12 * (score_rec_ras == 4) * (pop_rec_ras == 3) + \
            13 * (score_rec_ras == 5) * (pop_rec_ras == 1) + \
            14 * (score_rec_ras == 5) * (pop_rec_ras == 2) + \
            15 * (score_rec_ras == 5) * (pop_rec_ras == 3)

        meta1.update(dtype=rasterio.float32)

        combined_rec = f"{workingDir}{Insights_folder}/{Insights_combine}/Enablement_&_Population_Combined_classification.tif"
        with rasterio.open(combined_rec, 'w', **meta1) as dst:
            dst.write(result, 1)

        styleTemplate = f"{current_script_path}/Style/Insights Combined.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_combine}/"
        styleFile = f"{combined_rec.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.Insights_Reclass_Input_Field.setFilePath(f"{combined_rec}")
        self.dlg.Insights_Agg_Input_Field.setFilePath(f"{combined_rec}")
        self.dlg.Insights_Buf_Input_Field.setFilePath(f"{combined_rec}")

        layer0 = QgsRasterLayer(combined_rec, f"Enablement_&_Population_Combined_classification")
        QgsProject.instance().addMapLayer(layer0)

        self.dlg.Combine_status.setText("Classification Complete!")
        self.dlg.Combine_status.repaint()

    def Aggregationinsights(self):
        '''
        this function takes the combine raster output produced by the "combineReclassInsights" function and aggregates, by extracting
        the to the majority class to a polygon layer representing boundaries of interest for aggregation (e.g. municipal boundary layer).
        '''
        self.dlg.Aggregate_status.setText("")
        self.dlg.Aggregate_status.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()

        os.chdir(workingDir)
        Insights_folder = "Insights"
        if os.path.exists(Insights_folder):
            pass
        else:
            os.mkdir(Insights_folder)

        tempDir = f"temp"
        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        # INPUT
        insights_raster = self.dlg.Insights_Agg_Input_Field.filePath()
        aggregation_polygon = self.dlg.Insights_Polygon_Input_Field.filePath()

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]

        # TEMP OUTPUT
        aggregation_polygon_utm = f"{tempDir}/aggregation_polygon_utm.shp"

        self.dlg.Aggregate_status.setText("Variables Set")
        self.dlg.Aggregate_status.repaint()

        self.dlg.Aggregate_status.setText("Processing...")
        self.dlg.Aggregate_status.repaint()

        self.convertCRS(aggregation_polygon, UTM_crs)
        shp_utm.to_file(aggregation_polygon_utm)

        Insights_aggregation = "4) Aggregation"
        if os.path.exists(f"{Insights_folder}/{Insights_aggregation}"):
            pass
        else:
            os.mkdir(f"{Insights_folder}/{Insights_aggregation}")

        shpOutput = f"{workingDir}{Insights_folder}/{Insights_aggregation}/" + self.dlg.AGG_Output_Field.text() + ".shp"

        processing.run("native:zonalstatisticsfb", {'INPUT': QgsProcessingFeatureSourceDefinition(aggregation_polygon_utm,
                                                    selectedFeaturesOnly=False, featureLimit=-1,
                                                    flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                    geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                                    'INPUT_RASTER': insights_raster,
                                                    'RASTER_BAND': 1, 'COLUMN_PREFIX': '_', 'STATISTICS': [9],
                                                    'OUTPUT': shpOutput})

        styleTemplate = f"{current_script_path}/Style/Insights Aggregation.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_aggregation}/"
        styleFile = f"{self.dlg.AGG_Output_Field.text()}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        self.dlg.Insights_AGGReclass_Input_Field.setFilePath(f"{shpOutput}")
        self.dlg.Insights_AGGReclass_Input_Field_2.setFilePath(f"{shpOutput}")

        self.dlg.Aggregate_status.setText("Aggregation Complete!")
        self.dlg.Aggregate_status.repaint()


    def reZones(self):
        self.dlg.REzone_status.setText("")
        self.dlg.REzone_status.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()

        os.chdir(workingDir)
        Insights_folder = "Insights"
        if os.path.exists(Insights_folder):
            pass
        else:
            os.mkdir(Insights_folder)

        tempDir = f"temp"
        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        # INPUT
        reclassified_layer = self.dlg.Insights_Reclass_Input_Field.filePath()
        re_zones = self.dlg.Insights_RE_Input_Field.filePath()
        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]
        countryLayer = self.dlg.countryLayer_Field.filePath()
        pixelSize = self.dlg.pixelSize_SB.value()
        aggregate = self.dlg.Insights_AGGReclass_Input_Field.filePath()

        # Temp OUTPUT
        REtempResample = f"{tempDir}/REtempResample.tif"
        countryUTMLayerBuf = f"{tempDir}/countryUTMLayerBuf.shp"
        poly_temp = f"{tempDir}/poly_temp.shp"
        temp_dis = f"{tempDir}/temp_dis.shp"
        final_temp_dis = f"{tempDir}/final_temp_dis.shp"

        self.dlg.REzone_status.setText("Variables Set")
        self.dlg.REzone_status.repaint()

        self.dlg.REzone_status.setText("Processing...")
        self.dlg.REzone_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        countryUTMLayer = QgsVectorLayer(shp_utm.to_json(), "countryUTMLayer", "ogr")

        buffer = processing.run("native:buffer", {'INPUT': countryUTMLayer,
                                                  'DISTANCE': 2000,
                                                  'SEGMENTS': 5,
                                                  'END_CAP_STYLE': 0,
                                                  'JOIN_STYLE': 0,
                                                  'MITER_LIMIT': 2,
                                                  'DISSOLVE': True,
                                                  'SEPARATE_DISJOINT': False,
                                                  'OUTPUT': countryUTMLayerBuf})

        CountryBuf_df = gpd.read_file(countryUTMLayerBuf)
        country_extent = CountryBuf_df.total_bounds

        processing.run("gdal:warpreproject", {
            'INPUT': re_zones,
            'SOURCE_CRS': None,
            'TARGET_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'RESAMPLING': 0,
            'NODATA': None,
            'TARGET_RESOLUTION': pixelSize,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'TARGET_EXTENT': f'{country_extent[0]},{country_extent[2]},{country_extent[1]},{country_extent[3]} [{UTM_crs}]',
            'TARGET_EXTENT_CRS': QgsCoordinateReferenceSystem(UTM_crs),
            'MULTITHREADING': False,
            'EXTRA': '',
            'OUTPUT': REtempResample})

        Insights_re_raster= "5) RE Zone Raster Locations"
        if os.path.exists(f"{Insights_folder}/{Insights_re_raster}"):
            pass
        else:
            os.mkdir(f"{Insights_folder}/{Insights_re_raster}")

        # Reclassified rasters join to RE zones
        with rasterio.open(reclassified_layer) as src:
            reclassified_layer_ras = src.read(1)
            meta1 = src.meta
            
        with rasterio.open(REtempResample) as src:
            re_zones = src.read(1)
            re_zones[np.isinf(re_zones)] = src.nodata
            re_zones[re_zones != src.nodata] = 1

        # Raster Calculation
        result = reclassified_layer_ras * re_zones

        meta1.update(dtype=rasterio.float32)

        combined_RE = f"{workingDir}{Insights_folder}/{Insights_re_raster}/" + self.dlg.RE_Output_Field.text() + "Enablement_&_Population_Combined.tif"
        with rasterio.open(combined_RE, 'w', **meta1) as dst:
            dst.write(result, 1)

        styleTemplate = f"{current_script_path}/Style/Insights Combined.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_re_raster}/"
        styleFile = f"{combined_RE.split('.')[0]}.qml"
        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        # Vectorize raster
        Polygon = processing.run("gdal:polygonize", {'INPUT': combined_RE,
                                                     'BAND': 1,
                                                     'FIELD': 'DN',
                                                     'EIGHT_CONNECTEDNESS': False,
                                                     'EXTRA': '',
                                                     'OUTPUT': poly_temp})

        Dissolve = processing.run("native:dissolve", {'INPUT': poly_temp,
                                                      'FIELD': ['DN'],
                                                      'SEPARATE_DISJOINT': False,
                                                      'OUTPUT': temp_dis})

        gdf = gpd.read_file(temp_dis)
        gdf = gdf[(gdf['DN'] > 0) & (gdf['DN'] < 15)]
        gdf.to_file(final_temp_dis)

        # Load the main polygon layer
        main_layer = gpd.read_file(aggregate)

        # Load the layer you want to check for intersection
        intersect_layer = gpd.read_file(final_temp_dis)

        # Perform a spatial join
        intersecting_records = gpd.sjoin(main_layer, intersect_layer, how='inner', op='intersects')

        # Extract the intersecting polygons
        intersecting_polygons = main_layer.loc[intersecting_records.index]

        # Save to a new shapefile
        admin_RE = f"{workingDir}{Insights_folder}/{Insights_re_raster}/" + self.dlg.RE_Output_Field.text() + "admin_units_intersection.shp"
        intersecting_polygons.to_file(admin_RE)


        styleTemplate = f"{current_script_path}/Style/Insights Aggregation.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_re_raster}/"
        styleFile = f"{admin_RE.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))


        layer4 = QgsVectorLayer(admin_RE, f"{self.dlg.RE_Output_Field.text()}admin_unit_intersection")
        QgsProject.instance().addMapLayer(layer4)

        layer3 = QgsRasterLayer(combined_RE, f"{self.dlg.RE_Output_Field.text()}Enablement_&_Population_Combined")
        QgsProject.instance().addMapLayer(layer3)

        self.dlg.REzone_status.setText("RE Zones extraction complete!")
        self.dlg.REzone_status.repaint()

    def Bufferinsights(self):
        self.dlg.REpoint_status.setText("")
        self.dlg.REpoint_status.repaint()
        current_script_path = os.path.dirname(os.path.abspath(__file__))
        workingDir = self.dlg.workingDir_Field.text()

        os.chdir(workingDir)
        Insights_folder = "Insights"
        if os.path.exists(Insights_folder):
            pass
        else:
            os.mkdir(Insights_folder)

        tempDir = f"temp"
        if os.path.exists(tempDir):
            shutil.rmtree(tempDir)
        else:
            pass

        time.sleep(0.5)
        os.mkdir(tempDir)

        # INPUT
        insights_raster = self.dlg.Insights_Buf_Input_Field.filePath()
        location_point = self.dlg.Insights_Points_Input_Field.filePath()
        countryLayer = self.dlg.countryLayer_Field.filePath()
        aggregate = self.dlg.Insights_AGGReclass_Input_Field_2.filePath()
        bufferDistance = self.dlg.bufferDistance_SB.value()

        UTM_crs = str(self.dlg.mQgsProjectionSelectionWidget.crs()).split(" ")[-1][:-1]

        # TEMP OUTPUT
        adminUTMLayer = f"{tempDir}/adminUTMLayer.shp"
        location_point_utm = f"{tempDir}/aggregation_polygon_utm.shp"
        location_buffer = f"{tempDir}/location_buffer.shp"
        location_buffer_clip = f"{tempDir}/location_buffer_clip.shp"

        self.dlg.REpoint_status.setText("Variables Set")
        self.dlg.REpoint_status.repaint()

        self.dlg.REpoint_status.setText("Processing...")
        self.dlg.REpoint_status.repaint()

        self.convertCRS(countryLayer, UTM_crs)
        shp_utm.to_file(adminUTMLayer)

        self.convertCRS(location_point, UTM_crs)
        location_point_utm = QgsVectorLayer(shp_utm.to_json(), "location_point_utm", "ogr")


        processing.run("native:buffer", {'INPUT': location_point_utm,
                                         'DISTANCE': bufferDistance,
                                         'SEGMENTS': 5,
                                         'END_CAP_STYLE': 0,
                                         'JOIN_STYLE': 0,
                                         'MITER_LIMIT': 2,
                                         'DISSOLVE': False,
                                         'SEPARATE_DISJOINT': False,
                                         'OUTPUT': location_buffer})

        processing.run("native:clip", {'INPUT': location_buffer,
                                       'OVERLAY': QgsProcessingFeatureSourceDefinition(adminUTMLayer,
                                                    selectedFeaturesOnly=False, featureLimit=-1,
                                                    flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                    geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                       'OUTPUT': location_buffer_clip})

        Insights_re_point = "6) RE Point Locations"
        if os.path.exists(f"{Insights_folder}/{Insights_re_point}"):
            pass
        else:
            os.mkdir(f"{Insights_folder}/{Insights_re_point}")

        shpOutput = f"{workingDir}{Insights_folder}/{Insights_re_point}/" + self.dlg.Buffer_Output_Field.text() + f"{str(bufferDistance)}m_buffer.shp"

        processing.run("native:zonalstatisticsfb",{'INPUT': QgsProcessingFeatureSourceDefinition(location_buffer_clip,
                                                              selectedFeaturesOnly=False, featureLimit=-1,
                                                              flags=QgsProcessingFeatureSourceDefinition.FlagOverrideDefaultGeometryCheck,
                                                              geometryCheck=QgsFeatureRequest.GeometrySkipInvalid),
                                                    'INPUT_RASTER': insights_raster,
                                                    'RASTER_BAND': 1,
                                                    'COLUMN_PREFIX': '_',
                                                    'STATISTICS': [9],
                                                    'OUTPUT': shpOutput})

        styleTemplate = f"{current_script_path}/Style/Insights Buffer Aggregation.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_re_point}/"
        styleFile = f"{self.dlg.Buffer_Output_Field.text()}{str(bufferDistance)}m_buffer.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        # Load the main polygon layer
        main_layer = gpd.read_file(aggregate)

        # Load the layer you want to check for intersection
        intersect_layer = gpd.read_file(shpOutput)

        # Perform a spatial join
        intersecting_records = gpd.sjoin(main_layer, intersect_layer, how='inner', op='intersects')

        # Extract the intersecting polygons
        intersecting_polygons = main_layer.loc[intersecting_records.index]

        # Save to a new shapefile
        admin_RE = f"{workingDir}{Insights_folder}/{Insights_re_point}/" + self.dlg.Buffer_Output_Field.text() + f"admin_unit_{str(bufferDistance)}m_buffer_intersection.shp"
        intersecting_polygons.to_file(admin_RE)

        styleTemplate = f"{current_script_path}/Style/Insights Aggregation.qml"
        styleFileDestination = f"{workingDir}{Insights_folder}/{Insights_re_point}/"
        styleFile = f"{admin_RE.split('.')[0]}.qml"

        shutil.copy(styleTemplate, os.path.join(styleFileDestination, styleFile))

        layer2 = QgsVectorLayer(admin_RE, f"{self.dlg.Buffer_Output_Field.text()}admin_unit_{str(bufferDistance)}m_buffer_intersection")
        QgsProject.instance().addMapLayer(layer2)

        layer = QgsVectorLayer(shpOutput, f"{self.dlg.Buffer_Output_Field.text()}{str(bufferDistance)}m_buffer")
        QgsProject.instance().addMapLayer(layer)

        self.dlg.REpoint_status.setText("RE point proximity complete!")
        self.dlg.REpoint_status.repaint()